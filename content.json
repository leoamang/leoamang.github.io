{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"docker安装及使用经验","slug":"docker安装及使用经验","date":"2022-06-03T00:31:14.000Z","updated":"2022-06-04T15:08:39.070Z","comments":true,"path":"2022/06/03/docker安装及使用经验/","link":"","permalink":"http://example.com/2022/06/03/docker%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E7%BB%8F%E9%AA%8C/","excerpt":"","text":"docker[TOC] 前提是在vscode上面使用docker命令时发现命令无法识别，在vscode中下载扩展docker后也依旧不行，后推断原因是本机并没有下载过docker,因此下面探究如何在windows系统下下载并使用docker。整个思路：首先下载docker desktop并配置好，之后在vscode中下载扩展，最后在程序中使用docker命令进行操作。 本机以前装过虚拟机，在很多教程中都需要下载hype，但是有解释说hyper下载后其他的虚拟机不能使用，所以本教程是在未下载hyper的情况下使用docker 关键词：docker+wsl 2， docker+vscode，远程连接已有的docker镜像并上传内容安装docker 搜索docker官网，下载适合于windows版本的docker desktop，下载成功后可以通过命令行cmd输入 docker --version 查看是否下载docker成功。 运行docker run hello-world时发现报错，打开docker desktop 同样发现报错，提示未下载WL2，网上教程和windows官方教程开始下载 WL2. 下载WL2 以管理员身份运行powershell &#x3D;&#x3D; （win+r 输入powershell ） + （打开后输入start-process PowerShell -verb runas即可进入管理员 模式的powershell，输入下面的代码： *wsl --install* 若运行之后返回帮助文档，即下列情况： 那么这个时候需要按顺序输入： *wsl --list --online*→查看可用发行版本 运行*wsl --install -d &lt;DistroName&gt;*→我选的ubuntu，把-d后面的替换掉即可&#x3D;&#x3D;wsl –install -d ubuntu 之后会要求设置账号和密码，设置linux用户名和密码，在下载时系统会提醒设置username和password，此用户名和密码特定于安装的每个单独的linux分发版，与windows用户名无关；能够运行sudo（super user do）管理命令。 12345账号：amang密码： 输入命令 wsl --list --verbose 查看安装在 Windows 计算机上的 Linux 发行版列表，其中包括状态（发行版是正在运行还是已停止）。 ubuntu默认的wsl版本是1，此时不要慌张，上述步骤是wsl官方给的安装目录下的第一个安装教程，接下来跳到第二个安装教程：**旧版本的手动安装步骤**。 启用适用于linux的windows子系统 （1） 启用适用于 Linux 的 Windows 子系统： 以管理员身份运行powershell dism.exe /online /enable-feature /featurename:Microsoft-Windodiws-Subsystem-Linux /all /norestart 结果会出现： -（2）检查自己电脑是否满足wl2的运行要求 以本机为例：X64，内部版本号19043，次要版本号1706，均高于所需的。查看自己电脑的版本。win+r输入winver，可以查看到 -（3）启用虚拟机功能 安装 WSL 2 之前，必须启用“虚拟机平台”可选功能。 计算机需要虚拟化功能才能使用此功能。 在powershell下面运行： dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart~~ -（4）下载linux内核更新包← 非常重要！！！！非常重要 下载适用于x64计算的WSL2 linux 内核更新包 下载完后打开docker desktop会发现不报错了，不会再提醒WSL2没下载成功！！！ 查看wsl，会发现 此时代表docker desktop可以打开了！ 配置docker首先知道报错的类型： 代表docker没有打开，这个时候可以看 docker desktop打开后是否表明正在运行 ↑ 这里是绿色，表示正在运行！！ 如果是别的颜色，表示没有运行。 上述报错可以从以下考虑： -（1）wsl2没配置好–可以从docker desktop上提示看到 … ​ https和http问题 docker没有配置信任路径： 上述是原始代码，需要加入 “insecure-registries”: [ “信任路径”] 然后登录，可以发现ok了。 在vscode中使用docker 下载扩展 之后就可以在vscode中使用docker了。 如何在连接docker的问题：通过登录docker docker login dorker镜像网址 docker pull 路径:latest docker build -t 路径latest . ← 有一个点，代表一层 docker push hub.路径:latest 2.出错类型及解决： （1）build时报错 push时报错 这个时候虽然镜像容器会create，但是实则不会push成功。 使用时需要查看有没有这个文件，同时根据需要修改后面的路径 （2）当（1）中的问题解决以后，会出现 X509错误，这个时候build之前最好pull一下之前的文件，之后build，push，会发现成功了。 总结： （1）docker最好用在虚拟环境下，但通过本教程可以在windows下面使用docker. （2）doker下载完之后需要配置WSL2，如果没有的话需要自行配置，不管是wsl 1 还是wsl 2 ，可以在控制面板→程序→启用或关闭windows功能，查看 这个是否勾选。 （3）下载过程中发现了一个很好用的软件：windows teminals。 安装 Windows 终端安装 | Microsoft Docs Windows Terminal 可以使用命令行接口运行任何应用程序。 它的主要功能包括多个选项卡、窗格、Unicode 和 UTF-8 字符支持、GPU 加速文本呈现引擎，你还可用它来创建你自己的主题并自定义文本、颜色、背景和快捷方式。 每当安装新的 WSL Linux 发行版时，都会在 Windows Terminal 中为其创建一个新实例，该实例可根据你的偏好进行自定义。 （4）开始通过适用于 Linux 的 Windows 子系统使用 Visual Studio Code a 在vscode中下载扩展 Remote - WSL。 b 在vscode中打开WSL项目。 在刚才下载的windows终端输入 code . c 从vscode中下载 还可以通过使用 VS Code 中的快捷方式 CTRL+SHIFT+P 调出命令面板，以访问更多 VS Code 远程选项。 如果随后键入 Remote-WSL，将看到可用的 VS Code 远程选项列表，使你可以在远程会话中重新打开文件夹，指定要在哪个发行版中打开，等等。 （5）用第一种安装方式安装WSL时选择ubuntu ，通过windows teminals可以发现建立了一个ubuntu虚拟机， 而且对应的wsl是 1，可以在windows powershell 管理员模式下输入wsl –set-version 2， 就是更新的linux发行版的名称，比如我最开始使用的是ubuntu，这里直接替换为wsl --set-version ubuntu 2，通过命令wsl --list --verbose可以看到版本变了： 这里有个思考，其实docker desktop用的其实是手动安装的wsl安装包下载的wsl2. （6）一些wsl 2代码 wsl --set-version&#x3D;&#x3D;wsl -l -v →查看linux发行版的wsl版本 wsl --install wsl --list --online wsl --install -d &lt;DistroName&gt; ​ 2022.06.04完成","categories":[],"tags":[]},{"title":"近期学习所思所想暂且存放之处","slug":"近期学习所思所想暂且存放之处","date":"2022-04-14T12:40:01.000Z","updated":"2022-04-14T14:01:05.722Z","comments":true,"path":"2022/04/14/近期学习所思所想暂且存放之处/","link":"","permalink":"http://example.com/2022/04/14/%E8%BF%91%E6%9C%9F%E5%AD%A6%E4%B9%A0%E6%89%80%E6%80%9D%E6%89%80%E6%83%B3%E6%9A%82%E4%B8%94%E5%AD%98%E6%94%BE%E4%B9%8B%E5%A4%84/","excerpt":"","text":"2022.4.14首先是ES6的学习今日大概搞清楚了生成器函数的声明和调用，通过下述的例子，表明我个人的理解： 题目：1）异步编程；2）1s后控制台打印111，2s后222，3s后333 思考：本文可以用setTimeout嵌套进行设计，但是如果嵌套的多，会有回调地狱，所以根据课程，本文使用生成器函数进行调用，生成器函数的声明和调用： 123456789101112function * gen()&#123; 第一个代码块 yield 111 第二个代码块 yield 222 第三个代码块 yield 333&#125;//调用let iteratior = gen()iterator.next()/ console.log(iterator.next)具体的细节等后期整理笔记时说出区别 针对刚开始的需求，设计代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewpoint&quot; content=&quot;width=device-width,initial-scale=1.0&quot;&gt; &lt;title&gt;生成器函数实例&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; //生成器函数异步变成，要求1s后显示111，2s后显示222，3s后显示333 function one()&#123; setTimeout(()=&gt;&#123; console.log(111) &#125;,1000) &#125; function two()&#123; setTimeout(()=&gt;&#123; console.log(222) &#125;,2000) &#125; function three()&#123; setTimeout(()=&gt;&#123; console.log(333) &#125;,3000) &#125; function *gen()&#123; one(); yield 111; two(); yield 222; three(); yield 333; &#125; let iterator = gen() console.log(iterator.next()) iterator.next() iterator.next() iterator.next() &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 首先定义了三个函数（其中setTimeout使用了箭头函数），之后定义了生成器函数gen（），之后调用，在这个过程中思考如下： （1）声明时：可以这么 12345678function *gen()&#123; one(); yield 111; two(); yield 222; three(); yield 333; &#125; 也可以这么 12345function *gen()&#123; yield one(); yield two(); yield three(); &#125; 说明执行迭代器的时候，虽然是一个代码块一个代码块的执行，但yield是一个代码段的分隔，所以yield后面的代码会随着第一个next的执行而执行：也就是说，第二个代码和第一个代码性质相同。那么为什么yield 111 不会显示呢，暂时猜想可能是因为one是函数，函数有执行的对象，所以就直接执行了，而111就是个数。 （2）调用时，可以把next()函数写在一起，也可以把它写在yield调用的函数里面。例如： 123456function one()&#123; setTimeout(()=&gt;&#123; console.log(111) iterator.next() &#125;,1000) &#125; 生成器函数应用2 调用用户数据订单数据和商品数据","categories":[],"tags":[]},{"title":"hexo+github(二)","slug":"hexo-github-二","date":"2022-04-09T13:50:59.000Z","updated":"2022-04-09T14:27:49.567Z","comments":true,"path":"2022/04/09/hexo-github-二/","link":"","permalink":"http://example.com/2022/04/09/hexo-github-%E4%BA%8C/","excerpt":"","text":"一 选择hexo自带的的图片插件 a:下载插件 hexo-asset-image npm install hexo-asset-image –save b：如果想添加图片到已经存在的md文件，那么这个时候直接自己创建一个与md文件同名的文件夹存放图片； ​ 如果这个时候还没有创建md文件，可以选择hexo n 新建一个md文件，这个时候可以看到自动创建了一个与md同名的文件夹。 c：更改congif.yml文件里面的post_asset_folder: false更改为post_asset_folder: true。 d：更改node.module&#x2F;hexo-asset-image下面的配置文件index.js为： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&#x27;use strict&#x27;;var cheerio = require(&#x27;cheerio&#x27;);// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-stringfunction getPosition(str, m, i) &#123; return str.split(m, i).join(m).length;&#125;hexo.extend.filter.register(&#x27;after_post_render&#x27;, function(data)&#123; var config = hexo.config; if(config.post_asset_folder)&#123; var link = data.permalink; var beginPos = getPosition(link, &#x27;/&#x27;, 3) + 1; var appendLink = &#x27;&#x27;; // In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;. // if not with index.html endpos = link.lastIndexOf(&#x27;.&#x27;) + 1 support hexo-abbrlink if(/.*\\/index\\.html$/.test(link)) &#123; // when permalink is end with index.html, for example 2019/02/20/xxtitle/index.html // image in xxtitle/ will go to xxtitle/index/ appendLink = &#x27;index/&#x27;; var endPos = link.lastIndexOf(&#x27;.&#x27;); &#125; else &#123; var endPos = link.lastIndexOf(&#x27;/&#x27;); &#125; link = link.substring(beginPos, endPos) + &#x27;/&#x27; + appendLink; var toprocess = [&#x27;excerpt&#x27;, &#x27;more&#x27;, &#x27;content&#x27;]; for(var i = 0; i &lt; toprocess.length; i++)&#123; var key = toprocess[i]; var $ = cheerio.load(data[key], &#123; ignoreWhitespace: false, xmlMode: false, lowerCaseTags: false, decodeEntities: false &#125;); $(&#x27;img&#x27;).each(function()&#123; if ($(this).attr(&#x27;src&#x27;))&#123; // For windows style path, we replace &#x27;\\&#x27; to &#x27;/&#x27;. var src = $(this).attr(&#x27;src&#x27;).replace(&#x27;\\\\&#x27;, &#x27;/&#x27;); if(!(/http[s]*.*|\\/\\/.*/.test(src) || /^\\s+\\//.test(src) || /^\\s*\\/uploads|images\\//.test(src))) &#123; // For &quot;about&quot; page, the first part of &quot;src&quot; can&#x27;t be removed. // In addition, to support multi-level local directory. var linkArray = link.split(&#x27;/&#x27;).filter(function(elem)&#123; return elem != &#x27;&#x27;; &#125;); var srcArray = src.split(&#x27;/&#x27;).filter(function(elem)&#123; return elem != &#x27;&#x27; &amp;&amp; elem != &#x27;.&#x27;; &#125;); if(srcArray.length &gt; 1) srcArray.shift(); src = srcArray.join(&#x27;/&#x27;); $(this).attr(&#x27;src&#x27;, config.root + link + src); console.info&amp;&amp;console.info(&quot;update link as:--&gt;&quot;+config.root + link + src); &#125; &#125;else&#123; console.info&amp;&amp;console.info(&quot;no src attr, skipped...&quot;); console.info&amp;&amp;console.info($(this)); &#125; &#125;); data[key] = $.html(); &#125; &#125;&#125;); tips：在本人尝试时为成功，老师指导后知道，是因为源程序正则表达式有问题，在博客对图片进行检查时发现映射的地址为.&#x2F;com，这个地址并不是本地的地址，更改正则表达式后发现可以找到本地图片的地址。 可以在index.js中加入console.info语句打印变量，查看问题！！！！ f：重启hexo服务器 hexo s 如果重启后仍然看不到图片，可以按顺序运行以下代码： hexo clean hexo g hexo d hexo s","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}]},{"title":"hexo+github","slug":"hexo-github-一","date":"2022-04-08T13:57:23.000Z","updated":"2022-04-09T14:11:47.237Z","comments":true,"path":"2022/04/08/hexo-github-一/","link":"","permalink":"http://example.com/2022/04/08/hexo-github-%E4%B8%80/","excerpt":"","text":"hexo和github连接免费搭建个人博客网站(小白)一 先下载node和git，这个我都已经下载了，所以这一步详细步骤省略，等之后在笔记本上尝试时再添加。下载完成后可以通过 -v &#x2F;-version查看node、npm和git版本确定是否下载成功 二 注册github账号，并创建仓库，设置ssh连接 （1）点击头像，选择new reposity，新建一个名为：用户名.github.io的仓库，比如说我的用户名是leoamang，那么我需要建立一个名为leoamang.github.io的仓库。 （2）配置SSH key：使用ssh key解决本地和服务器的连接问题。 a：在桌面上（我做的时候并没有在桌面上，就是任意的文件夹，不知道是否只有桌面才成功，待验证）使用git base here进行命令行，输入 git config –global user.name “username” (例如：git config –global user.name “leoamang”)， 输入git config –global user.email “youremail” (例如git config –global user.email “***@qq.com”）。 b：创建SSH，输入后一路回车就行 ssh-keygen -t rsa -C “youremail”（C大写） ​ C：在路径C:\\Users\\DELL.ssh的id_rsa.pub可以看到生成的ssh密钥。打开并复制。 （3）在github上设置密钥：点击头像→settings→找到ssh and GPG keys→new ssh key→粘贴复制的ssh密钥，随意起个名字，并保存。检查设置是否成功 ssh -T &#x67;&#105;&#x74;&#x40;&#103;&#105;&#116;&#104;&#x75;&#x62;&#46;&#99;&#x6f;&#109; 若出现Hi username！ You’ve successfully authenticated, but GitHub does not provide shell access. 三 下载hexo 在自己想要的位置创建一个文件夹，名叫hexo，在这个文件夹下打开git base here 使用npm全局安装hexo框架和deployer： npm install -g hexo-cli npm install hexo-deployer-git –save 若安装速度慢，或者不成功，更换npm镜像源（我第一次没成功，更换镜像源后成功） npm config set registry https://registry.npm.taobao.org。 安装完成后，初始化博客，会在hexo文件夹下面创建一个blog文件，或者直接hexo init不会创建blog文件夹 npm init blog 检测是否可以，新建一个新的博客，然后执行g和s，打开浏览器访问4000端口查看。 hexo n “test“ &#x3D;&#x3D;&#x3D; hexo new ”test“ hexo g hexo s ctrl+c可以退出hexo服务器 四 推送博客 在blog文件下面找到config.yml配置及文件，修改最后的内容为（注意冒号之后有空格，不然会提示出错）： type: gitrepo: github下的仓库的完整路径branch: master 上述都成功后，可以在blog&#x2F;source&#x2F;__post下面创建md文件，写完之后可以通过 hexo g -d 或者hexo d推送 常用命令： hexo n “博客名” &#x3D;&#x3D;&#x3D; hexo new “博客名” hexo g &#x3D;&#x3D;&#x3D; hexo generate 生成静态页面至public目录 hexo s &#x3D;&#x3D;&#x3D; hexo server 开启预览访问端口（ctrl+c退出） hexo d &#x3D;&#x3D;&#x3D; hexo deploy 部署到github hexo s -g 生成并本地预览 hexo g -d 生成并上传 &#x3D;&#x3D;&#x3D; hexo d -g","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2022-04-06T13:45:39.129Z","updated":"2022-04-06T13:45:39.129Z","comments":true,"path":"2022/04/06/hello-world/","link":"","permalink":"http://example.com/2022/04/06/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}]}