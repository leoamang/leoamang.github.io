{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"数据库mysql学习指南一","slug":"数据库mysql学习指南一","date":"2022-06-16T07:28:19.000Z","updated":"2022-06-16T07:32:54.802Z","comments":true,"path":"2022/06/16/数据库mysql学习指南一/","link":"","permalink":"http://example.com/2022/06/16/%E6%95%B0%E6%8D%AE%E5%BA%93mysql%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97%E4%B8%80/","excerpt":"","text":"flask开发有两种模式，一种是 写 model.py 生成数据库表，另一种是在navicat 里建表，反向工程生成 model.py，这个model.py就是把数据表和Python内存中的对象做一个映射，也就是sqlalchemy框架的作用。这样，你操作python内存中的对象就可以实现对数据库的增删改查了 –h老师 简单介绍SQLAlchemy 是 Python 著名的 ORM 工具包。通过 ORM，开发者可以用面向对象的方式来操作数据库，不再需要编写 SQL 语句。SQLAlchemy 支持多种数据库，除 sqlite 外，其它数据库需要安装第三方驱动。 SQLAlchemy是Python编程语言下的一款开源软件。提供了SQL工具包及对象关系映射（ORM，Object Relational Mapping）工具，ORM也就是采用对象关系映射的模式，使用这种模式可以将数据库中各种数据表之间的关系映射到程序中的对象。这种模式可以屏蔽底层的数据库的细节，不需要我们与复杂的 SQL 语句打交道，直接采用操作对象的形式操作就可以。 SQLAlchemy 取得成功的一个证明就是围绕它已建立了丰富的社区。针对 SQLAlchemy 的扩展和插件包括：declarative、Migrate、Elixir、SQLSoup、django-sqlalchemy、DBSprockets、FormAlchemy 和 z3c.sqlalchemy。 建立与数据库的连接Engine对象是使用SQLAIchemy的起点，根据Engine的构架示意图，Engine包括数据库连接池（Pool）和方言（Dialect，指不同数据库的sql语句等的语法差距），两者把一起对数据库的操作，以符合DBAPI（快速生成数据库的http接口服务，零代码开发，只需编写sql，就可以生成http api服务。是数据库的上层应用，方便数据库数据对外发布http服务）规范的方式与数据库交互。 python导入mysql下载库安装sqlalchemy和pymysql库 123pip install sqlalchemy pip install pymysql 导入必要的包1from sqlalchemy import create_engine,Table,Column,Integer,String,MetaData,ForeignKey 创建一个连接引擎1engine = create_engine(mysql+pymysql://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;dbname&gt;,echo=True) create_engine(“数据库类型+数据库驱动:&#x2F;&#x2F;数据库用户名:数据库密码@IP地址:端口&#x2F;数据库”，其他参数) 上文当中echo&#x3D;True是开启调试， 创建元数据：描述数据的数据（标签名称，比如id、name等属性名称）1metadata=Metadata(engine) 通过Metadata()方法创建了metadata实例，上述代码带上engine的目的是绑定要连接引擎，当对metadata实例进行操作的时候就会直接连接到数据库 添加表结构123456789101112131415161718192021uesr= Table(&#x27;user&#x27;,metadata,​ Column(&#x27;id&#x27;,Integer,primary_key=True),​ Column(&#x27;name&#x27;,String(20)),​ Column(&#x27;fullname&#x27;,String(40)),)address_table = Table(&#x27;address&#x27;,metadata,​ Column(&#x27;id&#x27;,Integer,primary_key=True),​ Column(&#x27;user_id&#x27;,None,ForeignKey(&#x27;user.id&#x27;)),​ Column(&#x27;email&#x27;,String(128),nulllable = False),) 其中，Table()方法用来创建表，第一个参数为表名，第二个是存入元数据，后面的参数使用**Column()**方法将数据库的每一个字段的数据参数设置好。 执行创建1metadata.create_all() 几种常用插件的数据库url格式： 1234567891011MySQL-Python mysql+mysqldb://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;[:&lt;port&gt;]/&lt;dbname&gt;pymysql mysql+pymysql://&lt;username&gt;:&lt;password&gt;@&lt;host&gt;/&lt;dbname&gt;[?&lt;options&gt;]MySQL-Connector mysql+mysqlconnector://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;[:&lt;port&gt;]/&lt;dbname&gt;cx_Oracle oracle+cx_oracle://user:pass@host:port/dbname[?key=value&amp;key=value...]","categories":[],"tags":[]},{"title":"os模块上传镜像","slug":"os模块上传镜像","date":"2022-06-15T13:00:00.000Z","updated":"2022-06-15T13:11:28.294Z","comments":true,"path":"2022/06/15/os模块上传镜像/","link":"","permalink":"http://example.com/2022/06/15/os%E6%A8%A1%E5%9D%97%E4%B8%8A%E4%BC%A0%E9%95%9C%E5%83%8F/","excerpt":"","text":"待完成ji紧接着上次的docker pull和docker push来说的 因为服务器部署完成后，我们操作服务器很麻烦，要记住很多命令，有时候有防火墙不开放22端口就麻烦了 这时候，可以将命令写到 后台 controller里，然后在浏览器里访问指定的路径，就可以调用命令行执行相应的操作了 以前用SVN的时候，没有本地仓库，提交了之后服务器自动拉取，重启进程，就更新服务器端的程序了 是的，就是你的笔记本里的浏览器就行，访问一个GET请求 本地 docker push 之后，GET请求进入服务器执行 docker pull ，然后 docker run -d -p … 1234567class UpdateServer(MethodView): def updateServer(self): os.system(&#x27;docker pull hub.neusncp.com:8888/lib/hk_flask:latest&#x27;) os.system(&#x27;docker pull hub.neusncp.com:8888/lib/emis:latest&#x27;) os.system(&#x27;cd /home/huangxy/emis/ &amp;&amp; docker-compose up -d&#x27;) return &#123;&#x27;message&#x27;: &#x27;Update server successfully.&#x27;&#125; 这部分很重要，告诉前台，访问API的时候，如果是以 emis 开头的，那就把请求转发到 api.sapi.show 这里 docker给不了域名，域名是我向网络运营商租用的，也就是给钱，告诉DNS厂商，这个域名指向某个服务器IP 嗯嗯，docker是一个容器，可以放在自己的电脑上，也可以放在阿里云，腾讯云这种托管的服务器上，一次开发到处移植 https://neuhxy90.github.io/2022/06/07/%E9%A1%B9%E7%9B%AE/%E9%A1%B5%E9%9D%A2%E7%82%B9%E5%87%BB%E6%8C%89%E9%92%AE%E5%AE%9E%E7%8E%B0%E7%B3%BB%E7%BB%9F%E5%9C%A8%E7%BA%BF%E5%8D%87%E7%BA%A7/ http://dell.sapi.show/docs docker build, push, pull 这种都是操作镜像，也就是相当于系统安装盘.iso docker run -d …这个操作相当于买了一个新电脑，并且用你build的系统安装盘给新装个系统* 现在我们的操作，相当于升级了系统安装盘，但是我们是在一个笔记本里，自己更新自己 ，如果我们把 hk_flask 安装在宿主机里就行了 这样可以单独写一个服务，专门用来升级用 在系统内通过http请求，自己更新自己，是可以的 就是还得配置好 通过博客记录的那个方法，能掌握怎么写新的接口了","categories":[],"tags":[]},{"title":"数据库mysql学习指南","slug":"数据库mysql学习指南","date":"2022-06-14T14:52:22.000Z","updated":"2022-06-16T07:32:00.413Z","comments":true,"path":"2022/06/14/数据库mysql学习指南/","link":"","permalink":"http://example.com/2022/06/14/%E6%95%B0%E6%8D%AE%E5%BA%93mysql%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/","excerpt":"","text":"MYsql数据库(安装教程)在mysql官网下载（community）mysql5.7.38版本 -1 installer安装教程 参考教程1root a1b2c3dd customs 选择下一步后excute（workbench是前端交互界面） 剩下的直接一路点下去 -2 配置环境变量第一步安装的时候数据库管理系统的安装路径： 我选的是D盘。 找到D盘中的文件，其中有很多二进制可执行文件，利用命令行cmd打开mysql.exe，在cmd中，不管是否配置环境变量都可以执行这个文件，当不配置环境变量，就只是切换到mysql.exe的目录下，才能执行mysql的启动命令，当配置了环境变量，只要打开了cmd，就可以任意一个路径下执行mysql的启动命令。 我的电脑→属性→高级→环境变量→a）在系统变量中直接创建MYSQL_HOME+b）系统变量中选择path a)系统变量中新建MYSQL_HOME b)将server的路径（打开bin后可以直接右键复制路径）添加到系统变量的path中 网上的教程是：**%MYSQL_HOME%\\bin** 网上的教程是先配置系统变量，再配置系统变量中的path→**%MYSQL_HOME%\\bin** 配置完成后cmd显示 使用mysql workbench操作数据库本文教程在下载mysql时就已经下载了workbench，所以这里不需要再下载 输入密码登录mysql，进入数据库可以看到 -1 新建数据库 name时名称 下面是编码方式，设置完成后点击apply 会自动生成创建数据库的语句，再次点击apply即可 之后可以在侧边navigator看到新建的数据库，如果看不到，可以选择底部的administration变为schemas。 -2 对数据库的增删改查（1）设置连接 选中刚建好的数据库，右键，设置为此次链接的默认数据库 （2）新建表格：菜单栏第五个图标&#x2F;选中新建的数据库中的tables右键中create table 新建表格的项目中添加column，设置column的datatype，primarykey等属性，之后点击执行。 点击apply还会自动生成SQL语句 点击表旁边的小信号就可以查看表目前的各种信息。 （3）查看表格数据 选中表格→右键→选择select rows （4）修改表格数据 双击表格中的null，输入数据，输入完成后点击右下角apply 插入中文时报错可能是表的设置问题：报错1366 解决办法（1）：修改表格的编码方式为uft8后apply，+修改当前行的编码方式为utf8后apply. 找到表名或者列名的小信息符号 （在workbench中使用这种方式） （2）修改my.ini文件 cmd ： 1show variables like ‘character%’； 看到server的编码模式不是utf8 。 网上的教程是在mysqldata的安装目录下找到my.ini文件，在安装过程中设置了mysqldata的安装路径，这个时候找到安装路径，就可以看到my.ini文件 用打开文本的方式打开，找到mysql下面的 去掉default前面的井号，等号后面加上utf8， 再找到mysqld下面的 如最后一行所示，如上述操作一样。 完成后重启mysql服务: win+r 输入services.msc，其中找到mysql，本地用的是 123net stop MySQL57net start MySQL57 如果不行的话，可以用管理员方式打开cmd。 错误原因： 1 提示服务名无效→查看windows下mysql服务的名称，如上图所示。 2 提示发生系统错误5 拒绝访问→未用管理员模式打开。 将数据库映射到本地ip上供给局域网中的其他用户使用","categories":[],"tags":[]},{"title":"2022年6月9日学习primevue和连接数据库","slug":"2022年6月9日学习primevue和连接数据库","date":"2022-06-09T13:19:19.000Z","updated":"2022-06-14T14:55:49.462Z","comments":true,"path":"2022/06/09/2022年6月9日学习primevue和连接数据库/","link":"","permalink":"http://example.com/2022/06/09/2022%E5%B9%B46%E6%9C%889%E6%97%A5%E5%AD%A6%E4%B9%A0primevue%E5%92%8C%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/","excerpt":"","text":"[TOC] primevueprimevue 类似于elementui，可以通过引用相关的模块设置页面。 今天的需求是设计数据界面，根据datatable设计出页面的基本格式，之后通过插入iuputnumber模块将某些部分设计为可输入数据，这样的话就可以设计出自己想要的页面 感悟：首先要理解例子中模块是怎么设计的，然后按照需求修改。 连接MYSQLdb资料来自于实验室的同学，写一个博客开始自己写 设计一个数据表 字段就对应前端项目里 那个表格里的列 数据的各个类型 参考 plf_log 那个表的设计 一般这几种类型就够用了 在 navicat 里 ctrl +D 是设计表的快捷键 12345678from select import selectconn = MySQLdb.connect(host = self.host, port=self.port, user = self.user, passwd = self.password, db = self.dbname, charset=&#x27;utf8&#x27;, autocommit=True) #连接cursor = conn.cursor() # 使用游标cursor.execute(f&quot;ALTER TABLE &#123;self.tablename&#125; ADD edge_pred real&quot;)cursor.execute(f&quot;ALTER TABLE &#123;self.tablename&#125; ADD cloud_pred real&quot;)cursor.execute(f&quot;ALTER TABLE &#123;self.tablename&#125; ADD y_interpolation real&quot;)selectupdata 12345678910111213141516171819202122232425262728293031cursor = conn.cursor() # 使用游标//创建train_data数据库//创建train_data数据库drop = &quot;drop table if exists train_data&quot;sql_createTb = &quot;&quot;&quot;CREATE TABLE train_data ( id INT PRIMARY KEY AUTO_INCREMENT, timestamp DATETIME, ak1 real, ak2 real, add_alkali_flow real, slurry_flow real, steam_pressure real, steam_flow real, y real, y_interpolation real) &quot;&quot;&quot;cursor.execute(drop)head1 = &quot;id, timestamp, ak1, ak2, add_alkali_flow, slurry_flow, steam_pressure, steam_flow, y&quot;cursor.execute(f&#x27;select %s from writedata order by `id` desc limit 0,&#123;timestep+ filter_step&#125;&#x27;%head1) # 数据查询最新一个data = cursor.fetchall()y_true = y_old+ (y_now - y_old)/num * i # 得到了最近相邻的阶跃值，进行插值处理//把y_interpolation写入cursor.execute(f&quot;update writedata set y_interpolation=&#x27;&#123;y_true&#125;&#x27; where id=&#x27;&#123;id_old+ i&#125;&#x27;&quot;) cursor.execute(f&quot;update train_data set y_interpolation=&#x27;&#123;y_true&#125;&#x27; where id=&#x27;&#123;id_old+ i&#125;&#x27;&quot;) # 插补值写入 我自己写的代码 增删改查 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697import pymysql#1 连接数据库def get_conn(): conn = pymysql.connect( host=&#x27;hub.neusncp.com&#x27;, port=13306, user=&#x27;root&#x27;, password=&#x27;mk5rpuPqNw8JHAh2&#x27;, db=&#x27;emis&#x27;, charset=&#x27;utf8&#x27;,autocommit=True, # 如果插入数据，， 是否自动提交? 和conn.commit()功能一致。​ )​ return conn#增加 def sql_insert_many(sql,args): conn = get_conn() cur = conn.cursor() # 创建游标 result = cur.executemany(query=sql, args=args) print(result) conn.commit() cur.close() conn.close()#删除def sql_delete(sql,args): conn = get_conn() cur = conn.cursor() result = cur.execute(sql,args) print(result) conn.commit() cur.close() conn.close()#更新def sql_update(sql,args): conn = get_conn() cur = conn.cursor() result = cur.execute(sql,args) print(result) conn.commit() cur.close() conn.close()#查询def sql_query(sql,args): conn = get_conn() cur = conn.cursor() cur.execute(sql,args) results = cur.fetchall() #print(type(results)) # 返回&lt;class &#x27;tuple&#x27;&gt; tuple元组类型​ for row in results:​ print(row)​ id = row[0]​ area_id = row[1]​ name = row[2]​ type = row[3]​ time = row[4]​ value = row[5]​ unit = row[6]​ print(&#x27; id: &#x27; + str(id) + &#x27; area_id: &#x27; + str(area_id) + &#x27; name: &#x27; + str(name) + &#x27; type: &#x27; + str(type) +&#x27; time: &#x27; + time +&#x27; value: &#x27; + str(value) + &#x27;unit&#x27;+str(unit) )​ pass​ conn.commit()​ cur.close()​ conn.close()def sql_search(): conn = get_conn(); cur = conn.cursor() sqli = &quot;select * from plf_data_fuel&quot; result = cur.execute(sqli) print(result) conn.commit() cur.close() conn.close()if __name__==&#x27;__main__&#x27;: #sql = &#x27;INSERT INTO plf_data_fuel VALUES(%s,%s,%s,%s,%s,%s,%s);&#x27; #args = [(0, &#x27;公司&#x27;,&#x27;选矿&#x27;,&#x27;指标&#x27;,&#x27;2022.6.11&#x27;,&#x27;150&#x27;,&#x27;升/千吨&#x27;), (1, &#x27;公司&#x27;,&#x27;采矿&#x27;,&#x27;消耗&#x27;,&#x27;2022.6.11&#x27;,&#x27;200&#x27;,&#x27;升&#x27;)]增加# sql = &#x27;DELETE FROM plf_data_fuel WHERE id = %s;&#x27;#args = (0,) # 单个元素的tuple写法sql_delete(sql,args)sql = &#x27;UPDATE plf_data_fuel SET value=%s WHERE id = %s;&#x27;args = (&#x27;150&#x27;, 0)sql_update(sql, args)sql = &#x27;SELECT * FROM plf_data_fuel;&#x27;sql_query(sql,None) CHA","categories":[],"tags":[]},{"title":"win10用命令行运行python脚本","slug":"win10用命令行运行python脚本","date":"2022-06-05T03:10:12.000Z","updated":"2022-06-07T08:36:06.538Z","comments":true,"path":"2022/06/05/win10用命令行运行python脚本/","link":"","permalink":"http://example.com/2022/06/05/win10%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BF%90%E8%A1%8Cpython%E8%84%9A%E6%9C%AC/","excerpt":"","text":"[TOC] win10用命令行运行python脚本1.解决输入pyhton后转入microsoft store （1）将anaconda加入环境变量中 此电脑右键→属性→关于下面的高级系统设置→对用户变量和系统变量的path*进行编辑→新建三个anaconda环境变量（最下面的三个） （2）windows搜索栏输入管理应用执行别名→应用安装程序python取消勾选 2.打开cmd命令行 （1）输入python代表进入python交互模式，可以通过输入代码得到相应的结果。 如果输入python没有进入交互模式，因为本机用的是anaconda，所以输入 conda info --envs查看环境 将py3虚拟环境激活： conda activate py3 激活后自动进入python虚拟环境，此时进入了交互模式 （2）进入.py文件所在的位置，打开cmd命令行，（等价于在当前文件夹右键打开windows powershell）输入python test.py，可以运行python脚本，例如： python调用cmd3种方式 1.python的OS模块os模块调用cmd命令有两种方式：**os.system()、os.popen()**都是用当前进程来调用。 -（1）**os.system()**是无法获取返回值的。当运行结束后接着往下面执行程序。 import os os.system(&quot;ipconfig&quot;) 报错并显示： 这个显示的是cmd下的结果，解决方案： 配置默认终端为powershell 打开终端→选择默认配置文件→选择powershell→运行程序即可 ps：之后再将默认终端换为cmd时发现不再报错。。。 -（2）os.popen()带返回值的，如何获取返回值。如： 12345import oscmd=&#x27;python&#x27;p = os.popen(cmd)Output_str = p.read()print (Output_str) 得到的是个字符串。 这两个都是用当前进程来调用，它们都是阻塞式的。 （1）首先理解括号里面的程序 cd &#x2F;××&#x2F;×× 进入文件夹 svn update注：后面也可以指定目录如果命令后无目录，则将当前目录及其子目录下的所有文件都更新到最新版本。 python manage.py db migrate python manage.py db upgrade 实际开发中使用flask-migrate来动态的迁移数据库，使用flask-migrate必须借助flask-script Pid 文件是包含进程标识号 (pid) 的文件，该文件存储在文件系统的明确定义位置，因此允许其他程序找出正在运行的脚本的 pid。 下面两种方法仅是记录。 2.管道subprocess模块（使用Popen模块产生新的process）运行原理会在当前进程下面产生子进程。 123sub=subprocess.Popen(cmd,shell=True,stdout=subprocess.PIPE)sub.wait()print sub.read() 现在大部分人都喜欢使用Popen。Popen方法不会打印出cmd在linux上执行的信息。的确，Popen非常强大，支持多种参数和模式。使用前需要from subprocess import Popen, PIPE。但是Popen函数有一个缺陷，就是它是一个阻塞的方法。如果运行cmd时产生的内容非常多，函数非常容易阻塞住。解决办法是不使用wait()方法，但是也不能获得执行的返回值了。 Popen原型是： [python] subprocess.Popen(args, bufsize&#x3D;0, executable&#x3D;None, stdin&#x3D;None, stdout&#x3D;None, stderr&#x3D;None, preexec_fn&#x3D;None, close_fds&#x3D;False, shell&#x3D;False, cwd&#x3D;None, env&#x3D;None, universal_newlines&#x3D;False, startupinfo&#x3D;None, creationflags&#x3D;0) 参数bufsize：指定缓冲。我到现在还不清楚这个参数的具体含义，望各个大牛指点。 参数executable用于指定可执行程序。一般情况下我们通过args参数来设置所要运行的程序。如果将参数shell设为 True，executable将指定程序使用的shell。在windows平台下，默认的shell由COMSPEC环境变量来指定。 参数stdin, stdout, stderr分别表示程序的标准输入、输出、错误句柄。他们可以是PIPE，文件描述符或文件对象，也可以设置为None，表示从父进程继承。 参数preexec_fn只在Unix平台下有效，用于指定一个可执行对象(callable object)，它将在子进程运行之前被调用。 参数Close_sfs：在windows平台下，如果close_fds被设置为True，则新创建的子进程将不会继承父进程的输入、输出、错误管 道。我们不能将close_fds设置为True同时重定向子进程的标准输入、输出与错误(stdin, stdout, stderr)。 如果参数shell设为true，程序将通过shell来执行。 参数cwd用于设置子进程的当前目录。 参数env是字典类型，用于指定子进程的环境变量。如果env &#x3D; None，子进程的环境变量将从父进程中继承。 参数Universal_newlines:不同操作系统下，文本的换行符是不一样的。如：windows下用’&#x2F;r&#x2F;n’表示换，而Linux下用 ‘&#x2F;n’。如果将此参数设置为True，Python统一把这些换行符当作’&#x2F;n’来处理。 参数startupinfo与createionflags只在windows下用效，它们将被传递给底层的CreateProcess()函数，用 于设置子进程的一些属性，如：主窗口的外观，进程的优先级等等。 subprocess.PIPE 在创建Popen对象时，subprocess.PIPE可以初始化stdin, stdout或stderr参数，表示与子进程通信的标准流。 subprocess.STDOUT 创建Popen对象时，用于初始化stderr参数，表示将错误通过标准输出流输出。 Popen的方法： Popen.poll() 用于检查子进程是否已经结束。设置并返回returncode属性。 Popen.wait() 等待子进程结束。设置并返回returncode属性。 Popen.communicate(input&#x3D;None) 与子进程进行交互。向stdin发送数据，或从stdout和stderr中读取数据。可选参数input指定发送到子进程的参数。 Communicate()返回一个元组：(stdoutdata, stderrdata)。注意：如果希望通过进程的stdin向其发送数据，在创建Popen对象的时候，参数stdin必须被设置为PIPE。同样，如 果希望从stdout和stderr获取数据，必须将stdout和stderr设置为PIPE。 Popen.send_signal(signal) 向子进程发送信号。 Popen.terminate() 停止(stop)子进程。在windows平台下，该方法将调用Windows API TerminateProcess()来结束子进程。 Popen.kill() 杀死子进程。 Popen.stdin 如果在创建Popen对象是，参数stdin被设置为PIPE，Popen.stdin将返回一个文件对象用于策子进程发送指令。否则返回None。 Popen.stdout 如果在创建Popen对象是，参数stdout被设置为PIPE，Popen.stdout将返回一个文件对象用于策子进程发送指令。否则返回 None。 Popen.stderr 如果在创建Popen对象是，参数stdout被设置为PIPE，Popen.stdout将返回一个文件对象用于策子进程发送指令。否则返回 None。 Popen.pid 获取子进程的进程ID。 Popen.returncode 获取进程的返回值。如果进程还没有结束，返回None。 例如： [python] p &#x3D; Popen(“cp -rf a&#x2F;* b&#x2F;“, shell&#x3D;True, stdout&#x3D;PIPE, stderr&#x3D;PIPE) p.wait() if p.returncode !&#x3D; 0: print “Error.” return -1————————————————版权声明：本文为CSDN博主「Sahadhammika」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/weixin_28419039/article/details/112825756 3.使用commands.getstatusoutput(‘cmd’)方法123status ,output = commands.getstatusoutput(&#x27;cmd&#x27;)status = commands.getstatus(&#x27;cmd&#x27;)output = commands.getoutput(&#x27;cmd&#x27;) 顾名思义，status，output分别是执行的状态和输出结果，但是这种方法在windows中不能用。这个方法也不会打印出cmd在linux上执行的信息。这个方法唯一的优点是，它不是一个阻塞的方法。即没有Popen函数阻塞的问题。使用前需要import commands。 例如： [python] status, output &#x3D; commands.getstatusoutput(“ls”) 还有只获得output和status的方法： [python] commands.getoutput(“ls”) commands.getstatus(“ls”)————————————————版权声明：本文为CSDN博主「Sahadhammika」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/weixin_28419039/article/details/112825756","categories":[],"tags":[]},{"title":"docker安装及使用经验","slug":"docker安装及使用经验","date":"2022-06-03T00:31:14.000Z","updated":"2022-06-04T15:18:41.058Z","comments":true,"path":"2022/06/03/docker安装及使用经验/","link":"","permalink":"http://example.com/2022/06/03/docker%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E7%BB%8F%E9%AA%8C/","excerpt":"","text":"docker[TOC] 前提是在vscode上面使用docker命令时发现命令无法识别，在vscode中下载扩展docker后也依旧不行，后推断原因是本机并没有下载过docker,因此下面探究如何在windows系统下下载并使用docker。整个思路：首先下载docker desktop并配置好，之后在vscode中下载扩展，最后在程序中使用docker命令进行操作。 本机以前装过虚拟机，在很多教程中都需要下载hype，但是有解释说hyper下载后其他的虚拟机不能使用，所以本教程是在未下载hyper的情况下使用docker 关键词：docker+wsl 2， docker+vscode，远程连接已有的docker镜像并上传内容安装docker 搜索docker官网，下载适合于windows版本的docker desktop，下载成功后可以通过命令行cmd输入 docker --version 查看是否下载docker成功。 运行docker run hello-world时发现报错，打开docker desktop 同样发现报错，提示未下载WL2，网上教程和windows官方教程开始下载 WL2. 下载WL2 以管理员身份运行powershell &#x3D;&#x3D; （win+r 输入powershell ） + （打开后输入start-process PowerShell -verb runas即可进入管理员 模式的powershell，输入下面的代码： *wsl --install* 若运行之后返回帮助文档，即下列情况： 那么这个时候需要按顺序输入： *wsl --list --online*→查看可用发行版本 运行*wsl --install -d &lt;DistroName&gt;*→我选的ubuntu，把-d后面的替换掉即可&#x3D;&#x3D;wsl –install -d ubuntu 之后会要求设置账号和密码，设置linux用户名和密码，在下载时系统会提醒设置username和password，此用户名和密码特定于安装的每个单独的linux分发版，与windows用户名无关；能够运行sudo（super user do）管理命令。 12345账号：amang密码： 输入命令 wsl --list --verbose 查看安装在 Windows 计算机上的 Linux 发行版列表，其中包括状态（发行版是正在运行还是已停止）。 ubuntu默认的wsl版本是1，此时不要慌张，上述步骤是wsl官方给的安装目录下的第一个安装教程，接下来跳到第二个安装教程：**旧版本的手动安装步骤**。 启用适用于linux的windows子系统 （1） 启用适用于 Linux 的 Windows 子系统： 以管理员身份运行powershell dism.exe /online /enable-feature /featurename:Microsoft-Windodiws-Subsystem-Linux /all /norestart 结果会出现： -（2）检查自己电脑是否满足wl2的运行要求 以本机为例：X64，内部版本号19043，次要版本号1706，均高于所需的。查看自己电脑的版本。win+r输入winver，可以查看到 -（3）启用虚拟机功能 安装 WSL 2 之前，必须启用“虚拟机平台”可选功能。 计算机需要虚拟化功能才能使用此功能。 在powershell下面运行： dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart~~ -（4）下载linux内核更新包← 非常重要！！！！非常重要 下载适用于x64计算的WSL2 linux 内核更新包 下载完后打开docker desktop会发现不报错了，不会再提醒WSL2没下载成功！！！ 查看wsl，会发现 此时代表docker desktop可以打开了！ 配置docker首先知道报错的类型： 代表docker没有打开，这个时候可以看 docker desktop打开后是否表明正在运行 ↑ 这里是绿色，表示正在运行！！ 如果是别的颜色，表示没有运行。 上述报错可以从以下考虑： -（1）wsl2没配置好–可以从docker desktop上提示看到 … ​ https和http问题 docker没有配置信任路径： 上述是原始代码，需要加入 “insecure-registries”: [ “信任路径”] 然后登录，可以发现ok了。 在vscode中使用docker 下载扩展 之后就可以在vscode中使用docker了。 如何在连接docker的问题：通过登录docker docker login dorker镜像网址 docker pull 路径:latest docker build -t 路径latest . ← 有一个点，代表一层 docker push hub.路径:latest 2.出错类型及解决： （1）build时报错 push时报错 这个时候虽然镜像容器会create，但是实则不会push成功。 使用时需要查看有没有这个文件，同时根据需要修改后面的路径 （2）当（1）中的问题解决以后，会出现 X509错误，这个时候build之前最好pull一下之前的文件，之后build，push，会发现成功了。 总结： （1）docker最好用在虚拟环境下，但通过本教程可以在windows下面使用docker. （2）doker下载完之后需要配置WSL2，如果没有的话需要自行配置，不管是wsl 1 还是wsl 2 ，可以在控制面板→程序→启用或关闭windows功能，查看 这个是否勾选。 （3）下载过程中发现了一个很好用的软件：windows teminals。 安装 Windows 终端安装 | Microsoft Docs Windows Terminal 可以使用命令行接口运行任何应用程序。 它的主要功能包括多个选项卡、窗格、Unicode 和 UTF-8 字符支持、GPU 加速文本呈现引擎，你还可用它来创建你自己的主题并自定义文本、颜色、背景和快捷方式。 每当安装新的 WSL Linux 发行版时，都会在 Windows Terminal 中为其创建一个新实例，该实例可根据你的偏好进行自定义。 （4）开始通过适用于 Linux 的 Windows 子系统使用 Visual Studio Code a 在vscode中下载扩展 Remote - WSL。 b 在vscode中打开WSL项目。 在刚才下载的windows终端输入 code . c 从vscode中下载 还可以通过使用 VS Code 中的快捷方式 CTRL+SHIFT+P 调出命令面板，以访问更多 VS Code 远程选项。 如果随后键入 Remote-WSL，将看到可用的 VS Code 远程选项列表，使你可以在远程会话中重新打开文件夹，指定要在哪个发行版中打开，等等。 （5）用第一种安装方式安装WSL时选择ubuntu ，通过windows teminals可以发现建立了一个ubuntu虚拟机， 而且对应的wsl是 1，可以在windows powershell 管理员模式下输入wsl –set-version 2， 就是更新的linux发行版的名称，比如我最开始使用的是ubuntu，这里直接替换为wsl --set-version ubuntu 2，通过命令wsl --list --verbose可以看到版本变了： 这里有个思考，其实docker desktop用的其实是手动安装的wsl安装包下载的wsl2. （6）一些wsl 2代码 wsl --set-version&#x3D;&#x3D;wsl -l -v →查看linux发行版的wsl版本 wsl --install wsl --list --online wsl --install -d &lt;DistroName&gt; （7）关于图片加载不成功的问题 绝对路径和相对路径 偏好设置中勾选优先使用相对路径，这个上传到github上才能看到 。 绝对：前面有磁盘等要素 相对 2022.06.04完成","categories":[],"tags":[]},{"title":"近期学习所思所想暂且存放之处","slug":"近期学习所思所想暂且存放之处","date":"2022-04-14T12:40:01.000Z","updated":"2022-04-14T14:01:05.722Z","comments":true,"path":"2022/04/14/近期学习所思所想暂且存放之处/","link":"","permalink":"http://example.com/2022/04/14/%E8%BF%91%E6%9C%9F%E5%AD%A6%E4%B9%A0%E6%89%80%E6%80%9D%E6%89%80%E6%83%B3%E6%9A%82%E4%B8%94%E5%AD%98%E6%94%BE%E4%B9%8B%E5%A4%84/","excerpt":"","text":"2022.4.14首先是ES6的学习今日大概搞清楚了生成器函数的声明和调用，通过下述的例子，表明我个人的理解： 题目：1）异步编程；2）1s后控制台打印111，2s后222，3s后333 思考：本文可以用setTimeout嵌套进行设计，但是如果嵌套的多，会有回调地狱，所以根据课程，本文使用生成器函数进行调用，生成器函数的声明和调用： 123456789101112function * gen()&#123; 第一个代码块 yield 111 第二个代码块 yield 222 第三个代码块 yield 333&#125;//调用let iteratior = gen()iterator.next()/ console.log(iterator.next)具体的细节等后期整理笔记时说出区别 针对刚开始的需求，设计代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewpoint&quot; content=&quot;width=device-width,initial-scale=1.0&quot;&gt; &lt;title&gt;生成器函数实例&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; //生成器函数异步变成，要求1s后显示111，2s后显示222，3s后显示333 function one()&#123; setTimeout(()=&gt;&#123; console.log(111) &#125;,1000) &#125; function two()&#123; setTimeout(()=&gt;&#123; console.log(222) &#125;,2000) &#125; function three()&#123; setTimeout(()=&gt;&#123; console.log(333) &#125;,3000) &#125; function *gen()&#123; one(); yield 111; two(); yield 222; three(); yield 333; &#125; let iterator = gen() console.log(iterator.next()) iterator.next() iterator.next() iterator.next() &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 首先定义了三个函数（其中setTimeout使用了箭头函数），之后定义了生成器函数gen（），之后调用，在这个过程中思考如下： （1）声明时：可以这么 12345678function *gen()&#123; one(); yield 111; two(); yield 222; three(); yield 333; &#125; 也可以这么 12345function *gen()&#123; yield one(); yield two(); yield three(); &#125; 说明执行迭代器的时候，虽然是一个代码块一个代码块的执行，但yield是一个代码段的分隔，所以yield后面的代码会随着第一个next的执行而执行：也就是说，第二个代码和第一个代码性质相同。那么为什么yield 111 不会显示呢，暂时猜想可能是因为one是函数，函数有执行的对象，所以就直接执行了，而111就是个数。 （2）调用时，可以把next()函数写在一起，也可以把它写在yield调用的函数里面。例如： 123456function one()&#123; setTimeout(()=&gt;&#123; console.log(111) iterator.next() &#125;,1000) &#125; 生成器函数应用2 调用用户数据订单数据和商品数据","categories":[],"tags":[]},{"title":"hexo+github(二)","slug":"hexo-github-二","date":"2022-04-09T13:50:59.000Z","updated":"2022-04-09T14:27:49.567Z","comments":true,"path":"2022/04/09/hexo-github-二/","link":"","permalink":"http://example.com/2022/04/09/hexo-github-%E4%BA%8C/","excerpt":"","text":"一 选择hexo自带的的图片插件 a:下载插件 hexo-asset-image npm install hexo-asset-image –save b：如果想添加图片到已经存在的md文件，那么这个时候直接自己创建一个与md文件同名的文件夹存放图片； ​ 如果这个时候还没有创建md文件，可以选择hexo n 新建一个md文件，这个时候可以看到自动创建了一个与md同名的文件夹。 c：更改congif.yml文件里面的post_asset_folder: false更改为post_asset_folder: true。 d：更改node.module&#x2F;hexo-asset-image下面的配置文件index.js为： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&#x27;use strict&#x27;;var cheerio = require(&#x27;cheerio&#x27;);// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-stringfunction getPosition(str, m, i) &#123; return str.split(m, i).join(m).length;&#125;hexo.extend.filter.register(&#x27;after_post_render&#x27;, function(data)&#123; var config = hexo.config; if(config.post_asset_folder)&#123; var link = data.permalink; var beginPos = getPosition(link, &#x27;/&#x27;, 3) + 1; var appendLink = &#x27;&#x27;; // In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;. // if not with index.html endpos = link.lastIndexOf(&#x27;.&#x27;) + 1 support hexo-abbrlink if(/.*\\/index\\.html$/.test(link)) &#123; // when permalink is end with index.html, for example 2019/02/20/xxtitle/index.html // image in xxtitle/ will go to xxtitle/index/ appendLink = &#x27;index/&#x27;; var endPos = link.lastIndexOf(&#x27;.&#x27;); &#125; else &#123; var endPos = link.lastIndexOf(&#x27;/&#x27;); &#125; link = link.substring(beginPos, endPos) + &#x27;/&#x27; + appendLink; var toprocess = [&#x27;excerpt&#x27;, &#x27;more&#x27;, &#x27;content&#x27;]; for(var i = 0; i &lt; toprocess.length; i++)&#123; var key = toprocess[i]; var $ = cheerio.load(data[key], &#123; ignoreWhitespace: false, xmlMode: false, lowerCaseTags: false, decodeEntities: false &#125;); $(&#x27;img&#x27;).each(function()&#123; if ($(this).attr(&#x27;src&#x27;))&#123; // For windows style path, we replace &#x27;\\&#x27; to &#x27;/&#x27;. var src = $(this).attr(&#x27;src&#x27;).replace(&#x27;\\\\&#x27;, &#x27;/&#x27;); if(!(/http[s]*.*|\\/\\/.*/.test(src) || /^\\s+\\//.test(src) || /^\\s*\\/uploads|images\\//.test(src))) &#123; // For &quot;about&quot; page, the first part of &quot;src&quot; can&#x27;t be removed. // In addition, to support multi-level local directory. var linkArray = link.split(&#x27;/&#x27;).filter(function(elem)&#123; return elem != &#x27;&#x27;; &#125;); var srcArray = src.split(&#x27;/&#x27;).filter(function(elem)&#123; return elem != &#x27;&#x27; &amp;&amp; elem != &#x27;.&#x27;; &#125;); if(srcArray.length &gt; 1) srcArray.shift(); src = srcArray.join(&#x27;/&#x27;); $(this).attr(&#x27;src&#x27;, config.root + link + src); console.info&amp;&amp;console.info(&quot;update link as:--&gt;&quot;+config.root + link + src); &#125; &#125;else&#123; console.info&amp;&amp;console.info(&quot;no src attr, skipped...&quot;); console.info&amp;&amp;console.info($(this)); &#125; &#125;); data[key] = $.html(); &#125; &#125;&#125;); tips：在本人尝试时为成功，老师指导后知道，是因为源程序正则表达式有问题，在博客对图片进行检查时发现映射的地址为.&#x2F;com，这个地址并不是本地的地址，更改正则表达式后发现可以找到本地图片的地址。 可以在index.js中加入console.info语句打印变量，查看问题！！！！ f：重启hexo服务器 hexo s 如果重启后仍然看不到图片，可以按顺序运行以下代码： hexo clean hexo g hexo d hexo s","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}]},{"title":"hexo+github","slug":"hexo-github-一","date":"2022-04-08T13:57:23.000Z","updated":"2022-04-09T14:11:47.237Z","comments":true,"path":"2022/04/08/hexo-github-一/","link":"","permalink":"http://example.com/2022/04/08/hexo-github-%E4%B8%80/","excerpt":"","text":"hexo和github连接免费搭建个人博客网站(小白)一 先下载node和git，这个我都已经下载了，所以这一步详细步骤省略，等之后在笔记本上尝试时再添加。下载完成后可以通过 -v &#x2F;-version查看node、npm和git版本确定是否下载成功 二 注册github账号，并创建仓库，设置ssh连接 （1）点击头像，选择new reposity，新建一个名为：用户名.github.io的仓库，比如说我的用户名是leoamang，那么我需要建立一个名为leoamang.github.io的仓库。 （2）配置SSH key：使用ssh key解决本地和服务器的连接问题。 a：在桌面上（我做的时候并没有在桌面上，就是任意的文件夹，不知道是否只有桌面才成功，待验证）使用git base here进行命令行，输入 git config –global user.name “username” (例如：git config –global user.name “leoamang”)， 输入git config –global user.email “youremail” (例如git config –global user.email “***@qq.com”）。 b：创建SSH，输入后一路回车就行 ssh-keygen -t rsa -C “youremail”（C大写） ​ C：在路径C:\\Users\\DELL.ssh的id_rsa.pub可以看到生成的ssh密钥。打开并复制。 （3）在github上设置密钥：点击头像→settings→找到ssh and GPG keys→new ssh key→粘贴复制的ssh密钥，随意起个名字，并保存。检查设置是否成功 ssh -T &#x67;&#105;&#x74;&#x40;&#103;&#105;&#116;&#104;&#x75;&#x62;&#46;&#99;&#x6f;&#109; 若出现Hi username！ You’ve successfully authenticated, but GitHub does not provide shell access. 三 下载hexo 在自己想要的位置创建一个文件夹，名叫hexo，在这个文件夹下打开git base here 使用npm全局安装hexo框架和deployer： npm install -g hexo-cli npm install hexo-deployer-git –save 若安装速度慢，或者不成功，更换npm镜像源（我第一次没成功，更换镜像源后成功） npm config set registry https://registry.npm.taobao.org。 安装完成后，初始化博客，会在hexo文件夹下面创建一个blog文件，或者直接hexo init不会创建blog文件夹 npm init blog 检测是否可以，新建一个新的博客，然后执行g和s，打开浏览器访问4000端口查看。 hexo n “test“ &#x3D;&#x3D;&#x3D; hexo new ”test“ hexo g hexo s ctrl+c可以退出hexo服务器 四 推送博客 在blog文件下面找到config.yml配置及文件，修改最后的内容为（注意冒号之后有空格，不然会提示出错）： type: gitrepo: github下的仓库的完整路径branch: master 上述都成功后，可以在blog&#x2F;source&#x2F;__post下面创建md文件，写完之后可以通过 hexo g -d 或者hexo d推送 常用命令： hexo n “博客名” &#x3D;&#x3D;&#x3D; hexo new “博客名” hexo g &#x3D;&#x3D;&#x3D; hexo generate 生成静态页面至public目录 hexo s &#x3D;&#x3D;&#x3D; hexo server 开启预览访问端口（ctrl+c退出） hexo d &#x3D;&#x3D;&#x3D; hexo deploy 部署到github hexo s -g 生成并本地预览 hexo g -d 生成并上传 &#x3D;&#x3D;&#x3D; hexo d -g","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2022-04-06T13:45:39.129Z","updated":"2022-04-06T13:45:39.129Z","comments":true,"path":"2022/04/06/hello-world/","link":"","permalink":"http://example.com/2022/04/06/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}]}