{"meta":{"title":"Happy","subtitle":"","description":"成为一个可靠的人","author":"amang","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"多个node管理","slug":"多个node管理","date":"2023-03-10T02:05:14.000Z","updated":"2023-03-10T03:06:19.389Z","comments":true,"path":"2023/03/10/多个node管理/","link":"","permalink":"http://example.com/2023/03/10/%E5%A4%9A%E4%B8%AAnode%E7%AE%A1%E7%90%86/","excerpt":"","text":"缘由是因为拉取了svn的项目之后，npm报错node-sass有问题，查找后发现可能是node版本过高，因此想下载nvm管理包，切换不同的node版本。 查看node-sass和node匹配 https://www.npmjs.com/package/node-sass 利用NVM进行管理下载安装地址： https://github.com/coreybutler/nvm-windows/releases 下载第三个，完成后运行文件，这个版本下载就是for windows的。 安装安装过程中会设置nvm安装位置和node安装位置，因为本机安装了node16，所以安装时提醒已经安装了 node16，询问是否管理node16，点击确认后安装完成。 打开cmd命令行，输入nvm，如下图所示即表示安装完成。 管理node输入 nvm list 可以看到本机已经下载的版本， nvm命令行操作命令1,nvm nvm list 是查找本电脑上所有的node版本 - nvm list 查看已经安装的版本- nvm list installed 查看已经安装的版本- nvm list available 查看网络可以安装的版本 2,nvm install 安装最新版本nvm 3,nvm use &lt;version&gt; ## 切换使用指定的版本node 4,nvm ls 列出所有版本 5,nvm current显示当前版本 6,nvm alias &lt;name&gt; &lt;version&gt; ## 给不同的版本号添加别名 7,nvm unalias &lt;name&gt; ## 删除已定义的别名 8,nvm reinstall-packages &lt;version&gt; ## 在当前版本node环境下，重新全局安装指定版本号的npm包 9,nvm on 打开nodejs控制 10,nvm off 关闭nodejs控制 11,nvm proxy 查看设置与代理 12,nvm node_mirror [url] 设置或者查看setting.txt中的node_mirror，如果不设置的默认是 https://nodejs.org/dist/ nvm npm_mirror [url] 设置或者查看setting.txt中的npm_mirror,如果不设置的话默认的是： https://github.com/npm/npm/archive/. 13,nvm uninstall &lt;version&gt; 卸载制定的版本 14,nvm use [version] [arch] 切换制定的node版本和位数 15,nvm root [path] 设置和查看root路径 16,nvm version 查看当前的版本 问题及解决方案： 1.无法识别，这个是vscode的共性问题，也有可能识别不了其他的，所以这里设置vscode的属性，勾选以管理员身份运行即可。","categories":[],"tags":[{"name":"li","slug":"li","permalink":"http://example.com/tags/li/"}]},{"title":"svn","slug":"svn","date":"2023-03-07T14:24:37.000Z","updated":"2023-03-07T14:39:41.758Z","comments":true,"path":"2023/03/07/svn/","link":"","permalink":"http://example.com/2023/03/07/svn/","excerpt":"","text":"Tortoisesvn TortoiseSVN 是 Subversion 版本控制系统的一个免费开源客户端，可以超越时间的管理文件和目录 一、安装下载地址：Downloads · TortoiseSVN 根据电脑的配置选择svn，我选择下载64-bit版本，下载完安装包后正常点击就行 二、配置语言下载语言包，鼠标滚轮往下： 三、使用新建一个文件夹，在文件夹下右键，找到svn TortoiseSVN 使用教程 | 菜鸟教程 (runoob.com) 如何从svn上下载文件_svn下载文件_yijiaodingqiankun的博客-CSDN博客","categories":[],"tags":[]},{"title":"naiveui","slug":"naiveui","date":"2023-02-28T03:14:44.000Z","updated":"2023-03-07T14:43:42.583Z","comments":true,"path":"2023/02/28/naiveui/","link":"","permalink":"http://example.com/2023/02/28/naiveui/","excerpt":"","text":"naiveui推荐按需导入在搭建vite+vue3+ts的过程中，发现大家使用naive-ui组件，也是尤雨溪推荐的，所以尝试不选择antdesignvue。 参考文章 Vue3+TS+Vite+NaiveUI搭建一个项目骨架 - 掘金 (juejin.cn) https://blog.csdn.net/web22050702/article/details/126439121 [TOC] 安装yarn add naive-ui //2.34.3yarn add vfonts // 字体 0.0.3 配置naiveui自动导入功能（这里需要设置自动导入模块，如笔记开始的链接所示） ./vite.config.ts//从unplugin-vue-components/resolvers中引入NaiveUiResolver，并添加的在plugin中，示例代码如下：Components(&#123; resolvers: [ // 需要自动导入的组件 NaiveUiResolver() ], dts: &#x27;src/type/components.d.ts&#x27;,&#125;), Iconify IntelliSense - Iconify 图标插件 windicss IntelliSense - windicss 提示插件 I18n-ally - i18n 插件 Vetur - vue 开发必备 （也可以选择 Volar） ESLint - 脚本代码检查 Prettier - 代码格式化 Stylelint - css 格式化 DotENV - .env 文件 高亮 引入及使用https://yang-roc.blog.csdn.net/article/details/123473830?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2-123473830-blog-125608234.pc_relevant_3mothn_strategy_and_data_recovery&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2-123473830-blog-125608234.pc_relevant_3mothn_strategy_and_data_recovery&amp;utm_relevant_index=5 局部引入区别就是一个有setup，一个没有，我个人推荐setup在外面的方式 &lt;template&gt; &lt;n-button&gt;naive-ui&lt;/n-button&gt;&lt;/template&gt; &lt;script&gt; import &#123; defineComponent &#125; from &#x27;vue&#x27; import &#123; NButton &#125; from &#x27;naive-ui&#x27; export default defineComponent(&#123; components: &#123; NButton &#125; &#125;)&lt;/script&gt; &lt;template&gt; &lt;n-button&gt;naive-ui&lt;/n-button&gt;&lt;/template&gt; &lt;script setup&gt; import &#123; NButton &#125; from &#x27;naive-ui&#x27;&lt;/script&gt; 全局引入安装全部组件，打包会有冗余代码。 import &#123; createApp &#125; from &#x27;vue&#x27;import naive from &#x27;naive-ui&#x27; const app = createApp(App)app.use(naive) 布局（layout）这里是想做一个固定的顶、侧边栏以及底部，然后router仅填充内容即可。 这是整个后台骨架核心入口模板，就是登录之后的页面，通常会包含，左侧菜单导航，顶部，内容区域，如下： 这里直接用框架提供的，layout组件，自带了折叠，深色，固定定位，等功能，相对来说是非常方便，改动样式很少即可实现一个骨架。 手摸手，带你尝鲜 naiveui 撸 admin 骨架（核心骨架篇） - 知乎 (zhihu.com) 菜单 Menu - Naive UI https://www.bilibili.com/video/BV13Q4y167k6/?spm_id_from=333.337.search-card.all.click&amp;vd_source=e5c32794bf6b6e17ca459f7e3e208386 双击，把需要的内容加载出来 栅格： NaiveUI学习笔记：布局 - 掘金 (juejin.cn)","categories":[],"tags":[]},{"title":"pinia学习","slug":"pinia学习","date":"2023-02-28T00:35:30.000Z","updated":"2023-02-28T00:37:05.777Z","comments":true,"path":"2023/02/28/pinia学习/","link":"","permalink":"http://example.com/2023/02/28/pinia%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"定义一个 Store | Pinia 中文文档 (web3doc.top)","categories":[],"tags":[]},{"title":"vite+vue3+ts","slug":"vite-vue3-ts","date":"2023-02-27T13:43:45.000Z","updated":"2023-02-28T08:39:04.356Z","comments":true,"path":"2023/02/27/vite-vue3-ts/","link":"","permalink":"http://example.com/2023/02/27/vite-vue3-ts/","excerpt":"","text":"before目前已经尝试ant design vue2+ vue3+ts+echarts5+axios的结构，现在开始按照教程自己整一个架构 beginvite架构有自己本身的优势，但是我直接用的是别人搭建好的架构，所以用起来并不感觉快，所以自己创建项目。 创建vite+vue3项目yarn create vite Project name: » vite-project #回车 √ Project name: ... test? Select a framework: » - Use arrow-keys. Return to submit. Vanilla&gt; Vue React Preact Lit Svelte #选择vue架构 ? Select a variant: » - Use arrow-keys. Return to submit. JavaScript&gt; TypeScript Customize with create-vue Nuxt #选择语言编写ts 完成后出现 Done. Now run: cd test npm install npm run dev 安装less&#x2F;scss由于是使用vite,vite它提供了对 .scss, .sass, .less, .styl 和 .stylus 文件的内置支持,但必须安装相应的预处理器依赖;国内一般只使用 less 或 scss yarn add sass # 我只下载了sass ps：vscode插件，vetur是针对于vue2的，下载下面两个插件。 **TypeScript Vue Plugin** **Vue Language Features** 自动导入使用之后,不用导入vue中hook reactive ref yarn add -D unplugin-vue-components unplugin-auto-import import &#123; defineConfig &#125; from &#x27;vite&#x27;import vue from &#x27;@vitejs/plugin-vue&#x27;import &#123; resolve &#125; from &quot;path&quot;;// 自动导入vue中hook reactive ref等import AutoImport from &quot;unplugin-auto-import/vite&quot;//自动导入ui-组件 比如说ant-design-vue element-plus等import Components from &#x27;unplugin-vue-components/vite&#x27;;// https://vitejs.dev/config/export default defineConfig(&#123; plugins: [ vue(), AutoImport(&#123; //安装两行后你会发现在组件中不用再导入ref，reactive等 imports: [&#x27;vue&#x27;, &#x27;vue-router&#x27;], //存放的位置 dts: &quot;src/auto-import.d.ts&quot;, &#125;), Components(&#123; // 引入组件的,包括自定义组件 // 存放的位置 dts: &quot;src/components.d.ts&quot;, &#125;), ],&#125;） 配置别名import &#123; defineConfig &#125; from &#x27;vite&#x27;import type &#123; ConfigEnv &#125; from &#x27;vite&#x27; //别名配置import vue from &#x27;@vitejs/plugin-vue&#x27;import &#123; resolve &#125; from &#x27;path&#x27; //别名配置import AutoImport from &#x27;unplugin-auto-import/vite&#x27; //自动导入import Components from &#x27;unplugin-vue-components/vite&#x27; //组件按需导入；import &#123; NaiveUiResolver &#125; from &#x27;unplugin-vue-components/resolvers&#x27;// https://vitejs.dev/config/export default defineConfig((&#123; mode &#125;: ConfigEnv) =&gt; &#123; //别名配置 return &#123; //别名配置 server: &#123; open: true, cors: true, // 默认启用并允许任何源 host: &#x27;localhost&#x27;, port: 3000, //这里的ip和端口是前端项目的;下面为需要跨域访问后端项目 proxy: &#123; &#x27;/api&#x27;: &#123; target: &#x27;http://localhost:8888&#x27;, changeOrigin: true, //正则表达式，将/api给替换掉 rewrite: (path) =&gt; path.replace(/^\\/api/, &#x27;&#x27;) &#125; &#125;&#125;, plugins: [ vue(), AutoImport(&#123; resolvers: [], // 自定引入 Vue VueRouter API,如果还需要其他的可以自行引入 imports: [&#x27;vue&#x27;, &#x27;vue-router&#x27;], // 调整自动引入的文件位置 dts: &#x27;src/type/auto-import.d.ts&#x27;, // 解决自动引入eslint报错问题 需要在eslintrc的extend选项中引入 eslintrc: &#123; enabled: true, // 配置文件的位置 filepath: &#x27;./.eslintrc-auto-import.json&#x27;, globalsPropValue: true, &#125;, &#125;), Components(&#123; resolvers: [ // 需要自动导入的组件 NaiveUiResolver() ], dts: &#x27;src/type/components.d.ts&#x27;, &#125;), ], resolve: &#123; //别名配置 alias: &#123; &#x27;/@&#x27;: resolve(__dirname, &#x27;src&#x27;), &#125;, extensions: [&#x27;.js&#x27;, &#x27;.json&#x27;, &#x27;.ts&#x27;, &#x27;.vue&#x27;], // 使用路径别名时想要省略的后缀名，可以自己 增减 &#125;,&#125;&#125;) 如果出现报错__dirname 找不到，yarn add @types/node即可 如果出现报错path没有，那么yarn add path即可 路由yarn add vue-router@4 在main.ts中引入 #main.jsimport &#123; createApp &#125; from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27; //routes import router from &quot;./routes/index&quot;; const app= createApp(App) //routes app.use(router) app.mount(&#x27;#app&#x27;)这里有一个问题，原始的main.ts中用的是createApp(App).mount(&#x27;#app&#x27;)一条语句代表const app= createApp(App)和app.mount(&#x27;#app&#x27;)两句话，因为之后还要使用app.，所以将该句拆分。 #./src/routes/index.tsimport &#123; createRouter, createWebHistory &#125; from &quot;vue-router&quot;;let routes= [ &#123; path: &#x27;/&#x27;, name: &#x27;home&#x27;, //使用import可以路由懒加载，如果不使用，太多组件一起加载会造成白屏 component: () =&gt; import(&#x27;../view/homeView.vue&#x27;) &#125;, //&#123; //配置404页面 //path: &#x27;/:catchAll(.*)&#x27;, //name: &#x27;404&#x27;, //component: () =&gt; import(&#x27;&#x27;), //&#125;]// 路由const router = createRouter(&#123; history: createWebHistory(), routes&#125;)// 导出export default router 显示报错，**，在src下面创建一个view文件夹，新加一个homeView.vue界面 安装pinia因为是vue3+ts，安装pinia更好点，vuex拥抱ts没有pinia好 yarn add pinia 配置main.tsimport &#123; createApp &#125; from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;//piniaimport &#123; createPinia &#125; from &#x27;pinia&#x27; const pinia = createPinia()const app = createApp(App)//piniaapp.use(pinia)app.mount(&#x27;#app&#x27;) 在src下创建一个 store 文件夹，再创建一个 home.ts 文件 其它名也可以，因为pinia它有一个根文件，会把 defineStore 第一个参数当id值，相当于vuex中的 module 自动引入，也会在Vue.js devtools 插件中以第一个参数名展示（下面展示） 注意：defineStore第一个参数很重要，而且是唯一值。它的命名在devtools 插件能方便找到这个文件的数据，方便调试 介绍 | Pinia 中文文档 (web3doc.top) (17条消息) 手把手教你用 vite+vue3+ts+pinia+vueuse 打造大厂企业级前端项目_用vue做的企业项目_阿彪师傅的博客-CSDN博客 安装axios 安装 yarn add axios 封装request ./src/api/request.tsimport axios from &#x27;axios&#x27;// 创建axios实例const request = axios.create(&#123; baseURL: &#x27;&#x27;, // 所有的请求地址前缀部分(没有后端请求不用写) // 如果有后端，并在前端配置了代理，这里的路径写为需要替换的路径，例如/api。 timeout: 80000, // 请求超时时间(毫秒) withCredentials: true,// 异步请求携带cookie // headers: &#123; // 设置后端需要的传参类型 // &#x27;Content-Type&#x27;: &#x27;application/json&#x27;, // &#x27;token&#x27;: x-auth-token&#x27;,//一开始就要token // &#x27;X-Requested-With&#x27;: &#x27;XMLHttpRequest&#x27;, // &#125;,&#125;) // request拦截器request.interceptors.request.use( config =&gt; &#123; // 如果你要去localStor获取token // let token = localStorage.getItem(&quot;x-auth-token&quot;); // if (token) &#123; // config.headers = &#123;&quot;x-auth-token&quot;: token&#125; // &#125; return config &#125;, error =&gt; &#123; // 对请求错误做些什么 Promise.reject(error) &#125;) // response 拦截器request.interceptors.response.use( response =&gt; &#123; // 对响应数据做点什么 return response.data &#125;, error =&gt; &#123; // 对响应错误做点什么 return Promise.reject(error) &#125;)export default request 配置代理proxy ./vue.config.ts server: &#123; open: true, cors: true, // 默认启用并允许任何源 host: &#x27;localhost&#x27;, port: 3000, //这里的ip和端口是前端项目的;下面为需要跨域访问后端项目 proxy: &#123; &#x27;/api&#x27;: &#123; target: &#x27;http://localhost:8888&#x27;, changeOrigin: true, //正则表达式，将/api给替换掉 rewrite: (path) =&gt; path.replace(/^\\/api/, &#x27;&#x27;) &#125; &#125; &#125;, 使用 注意：因为get请求的参数需要params，它是即将与请求一起发送的 URL 参数，为了简写采用了ES6的解构，就是把下面的 params 解构，**只有get 请求需要加多一层params**。 其它请求，如 post 等请求等就不用解构，形参是什么都行。 请求数据 ./api/api.ts定义接口格式：export const 自定义接口名 = (形参) =&gt; instance.方法(路径，后端要的参数);","categories":[],"tags":[]},{"title":"数据库mysql学习指南一","slug":"数据库mysql学习指南一","date":"2022-06-16T07:28:19.000Z","updated":"2022-06-23T14:14:53.239Z","comments":true,"path":"2022/06/16/数据库mysql学习指南一/","link":"","permalink":"http://example.com/2022/06/16/%E6%95%B0%E6%8D%AE%E5%BA%93mysql%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97%E4%B8%80/","excerpt":"","text":"flask开发有两种模式，一种是 写 model.py 生成数据库表，另一种是在navicat 里建表，反向工程生成 model.py，这个model.py就是把数据表和Python内存中的对象做一个映射，也就是sqlalchemy框架的作用。这样，你操作python内存中的对象就可以实现对数据库的增删改查了 –h老师 简单介绍SQLAlchemy 是 Python 著名的 ORM 工具包。通过 ORM，开发者可以用面向对象的方式来操作数据库，不再需要编写 SQL 语句。SQLAlchemy 支持多种数据库，除 sqlite 外，其它数据库需要安装第三方驱动。 SQLAlchemy是Python编程语言下的一款开源软件。提供了SQL工具包及对象关系映射（ORM，Object Relational Mapping）工具，ORM也就是采用对象关系映射的模式，使用这种模式可以将数据库中各种数据表之间的关系映射到程序中的对象。这种模式可以屏蔽底层的数据库的细节，不需要我们与复杂的 SQL 语句打交道，直接采用操作对象的形式操作就可以。 SQLAlchemy 取得成功的一个证明就是围绕它已建立了丰富的社区。针对 SQLAlchemy 的扩展和插件包括：declarative、Migrate、Elixir、SQLSoup、django-sqlalchemy、DBSprockets、FormAlchemy 和 z3c.sqlalchemy。 建立与数据库的连接Engine对象是使用SQLAIchemy的起点，根据Engine的构架示意图，Engine包括数据库连接池（Pool）和方言（Dialect，指不同数据库的sql语句等的语法差距），两者把一起对数据库的操作，以符合DBAPI（快速生成数据库的http接口服务，零代码开发，只需编写sql，就可以生成http api服务。是数据库的上层应用，方便数据库数据对外发布http服务）规范的方式与数据库交互。 python导入mysqlsqlalchemy使用table、metadata和mapper做映射1下载库安装sqlalchemy和pymysql库 pip install sqlalchemy pip install pymysql 2 连接数据库 配置信息dialect+dirver://username:passwod@host:port/database,echo=True数据库类型+数据库驱动://数据库用户名:数据库密码@IP地址:端口/数据库，其他参数 dialect：数据库，如sqlite、mysql、oracledirver：数据库驱动，用于连接数据库的，如果是mysql则使用pymysqlusername：用户名password：密码host：IP地址port：端口database：数据库表格名称 echo:是否进入调试模式 HOST=&#x27;&#x27;PORT=USERNAME=&#x27;&#x27;PASSWORD=&#x27;&#x27;DB=&#x27;&#x27;//dialect+dirver://username:passwod@host:port/database,echo=TrueDB_URL=f&#x27;mysql+pymysql://&#123;USERNAME&#125;:&#123;PASSWORD&#125;@&#123;HOST&#125;:&#123;PORT&#125;/&#123;DB&#125;&#x27; 上述的配置可以放入config.py文件 创建引擎并连接数据库from sqlalchemy import create_enginefrom config import DB_URLengine = create_engine(DB_URL) #创建引擎conn=engine.connect() #连接数据库result=conn.excute(&#x27;SELECT 1&#x27;) #执行sql语句print(result.fetchone())conn.close() #关闭连接 创建ORM模型并映射到数据库from sqlalchemy.ext.declarative import declarative_basefrom sqlalchemy import create_engine,Column,Interger,Stringfrom sqlalchemy.orm import sessionmakerfrom config import DB_URLengine =create_engine(DB_URL)Base = declarative_base(engine) #SQL的ORM基类session = sessionmaker(engine)() #构建session对象 也可以写为Session=sessionmaker(engine) session=Session()class Student(Base): __tablename__=&#x27;student&#x27; id=Column(Integer,primary_key=True,autoincrement=True) name=Column(String(50)) age=Column(Integer) sex=Column(String(10)) Base.metadata.create_all() #将模型映射到数据库 3 对数据库的操作 新增数据（需要提交到数据库）student=Student(name=&#x27;tony&#x27;,age=&#x27;18&#x27;,sex=&#x27;男&#x27;)session.add(student) #添加到sessionsession.commit() #提交到数据库#批量添加数据session_add_all([ Student(name=&#x27;张三&#x27;,age=&#x27;18&#x27;,sex=&#x27;男&#x27;), Student(name=&#x27;李四&#x27;,age=&#x27;18&#x27;,sex=&#x27;女&#x27;)])session.commit() 查询数据 query()item_list = session.query(Student).all() #item_list是一个包含多个Student对象的列表print(item_list)for item in item_list: print(item.name,item,age) #指定查询列item_list=session.query(Student.name).all()print(item_list)#返回数据的第一行item=session.query(Student.name).first()print(item)#使用filter()方法进行筛选item_list=session.query(Student.name).filter(Student.age&gt;=18).all()print(item_list)#使用order_by()进行排序item_list=session.query(Student.name,Stugent.age).order_by(Student.age.desc()).all() #desc()表示倒序print(item_list)#多个查询条件(and 和 or)默认是anditem_list=session.query(Student.name,Stugent.age,Student.sex).filter(Student.age &gt;= 10, Student.sex == &#x27;female&#x27;).all()print(item_list)##orfrom sqlalchemy import or_item_list=session.query(Student.name,Stugent.age,Student.sex).filter(or_(Student.age &gt;= 20, Student.sex == &#x27;female&#x27;)).all()print(item_list)#equal/like/in#等于item_list=session.query(Student.name,Stugent.age,Student.sex).filter(Student.age == 18).all()print(item_list)#不等于item_list=session.query(Student.name,Stugent.age,Student.sex).filter(Student.age != 18).all()print(item_list)#likeitem_list=session.query(Student.name,Stugent.age,Student.sex).filter(Student.name.like(&#x27;%To%&#x27;)).all()print(item_list)#initem_list=session.query(Student.name,Stugent.age,Student.sex).filter(Student.age.in_[16,20]]).all()print(item_list)#count 计算个数count=session.query(Student).count()print(count) 计算数据的条数#切片item_list=session.query(Student.name).all()[:2]print(item_list) 修改数据updat（）需要提交到数据库session.query(Student).filter(Student.name == &#x27;Tony&#x27;).update(&#123;&#x27;age&#x27;:22&#125;)session.commit() 删除数据delete()session.query(Student).filter(Student.name==&#x27;Ben&#x27;).delete()session.commit() sqlalchemy的基本用法 - 蓝莓薄荷 - 博客园 (cnblogs.com) Flask-SQLAlchemy详解 - 简书 (jianshu.com) sqlalchemy使用delect https://www.csdn.net/tags/Ntzagg2sNTA4MDEtYmxvZwO0O0OO0O0O.html 几种常用插件的数据库url格式： MySQL-Python mysql+mysqldb://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;[:&lt;port&gt;]/&lt;dbname&gt;pymysql mysql+pymysql://&lt;username&gt;:&lt;password&gt;@&lt;host&gt;/&lt;dbname&gt;[?&lt;options&gt;]MySQL-Connector mysql+mysqlconnector://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;[:&lt;port&gt;]/&lt;dbname&gt;cx_Oracle oracle+cx_oracle://user:pass@host:port/dbname[?key=value&amp;key=value...] 2022.6.23","categories":[],"tags":[]},{"title":"os模块上传镜像","slug":"os模块上传镜像","date":"2022-06-15T13:00:00.000Z","updated":"2022-06-15T13:11:28.294Z","comments":true,"path":"2022/06/15/os模块上传镜像/","link":"","permalink":"http://example.com/2022/06/15/os%E6%A8%A1%E5%9D%97%E4%B8%8A%E4%BC%A0%E9%95%9C%E5%83%8F/","excerpt":"","text":"待完成ji紧接着上次的docker pull和docker push来说的 因为服务器部署完成后，我们操作服务器很麻烦，要记住很多命令，有时候有防火墙不开放22端口就麻烦了 这时候，可以将命令写到 后台 controller里，然后在浏览器里访问指定的路径，就可以调用命令行执行相应的操作了 以前用SVN的时候，没有本地仓库，提交了之后服务器自动拉取，重启进程，就更新服务器端的程序了 是的，就是你的笔记本里的浏览器就行，访问一个GET请求 本地 docker push 之后，GET请求进入服务器执行 docker pull ，然后 docker run -d -p … class UpdateServer(MethodView): def updateServer(self): os.system(&#x27;docker pull hub.neusncp.com:8888/lib/hk_flask:latest&#x27;) os.system(&#x27;docker pull hub.neusncp.com:8888/lib/emis:latest&#x27;) os.system(&#x27;cd /home/huangxy/emis/ &amp;&amp; docker-compose up -d&#x27;) return &#123;&#x27;message&#x27;: &#x27;Update server successfully.&#x27;&#125; 这部分很重要，告诉前台，访问API的时候，如果是以 emis 开头的，那就把请求转发到 api.sapi.show 这里 docker给不了域名，域名是我向网络运营商租用的，也就是给钱，告诉DNS厂商，这个域名指向某个服务器IP 嗯嗯，docker是一个容器，可以放在自己的电脑上，也可以放在阿里云，腾讯云这种托管的服务器上，一次开发到处移植 https://neuhxy90.github.io/2022/06/07/%E9%A1%B9%E7%9B%AE/%E9%A1%B5%E9%9D%A2%E7%82%B9%E5%87%BB%E6%8C%89%E9%92%AE%E5%AE%9E%E7%8E%B0%E7%B3%BB%E7%BB%9F%E5%9C%A8%E7%BA%BF%E5%8D%87%E7%BA%A7/ http://dell.sapi.show/docs docker build, push, pull 这种都是操作镜像，也就是相当于系统安装盘.iso docker run -d …这个操作相当于买了一个新电脑，并且用你build的系统安装盘给新装个系统* 现在我们的操作，相当于升级了系统安装盘，但是我们是在一个笔记本里，自己更新自己 ，如果我们把 hk_flask 安装在宿主机里就行了 这样可以单独写一个服务，专门用来升级用 在系统内通过http请求，自己更新自己，是可以的 就是还得配置好 通过博客记录的那个方法，能掌握怎么写新的接口了","categories":[],"tags":[]},{"title":"数据库mysql学习指南","slug":"数据库mysql学习指南","date":"2022-06-14T14:52:22.000Z","updated":"2022-06-19T13:42:09.822Z","comments":true,"path":"2022/06/14/数据库mysql学习指南/","link":"","permalink":"http://example.com/2022/06/14/%E6%95%B0%E6%8D%AE%E5%BA%93mysql%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/","excerpt":"","text":"MYsql数据库(安装教程)在mysql官网下载（community）mysql5.7.38版本 -1 installer安装教程 参考教程root a1b2c3dd customs 选择下一步后excute（workbench是前端交互界面） 剩下的直接一路点下去 -2 配置环境变量第一步安装的时候数据库管理系统的安装路径： 我选的是D盘。 找到D盘中的文件，其中有很多二进制可执行文件，利用命令行cmd打开mysql.exe，在cmd中，不管是否配置环境变量都可以执行这个文件，当不配置环境变量，就只是切换到mysql.exe的目录下，才能执行mysql的启动命令，当配置了环境变量，只要打开了cmd，就可以任意一个路径下执行mysql的启动命令。 我的电脑→属性→高级→环境变量→a）在系统变量中直接创建MYSQL_HOME+b）系统变量中选择path a)系统变量中新建MYSQL_HOME b)将server的路径（打开bin后可以直接右键复制路径）添加到系统变量的path中 网上的教程是：**%MYSQL_HOME%\\bin** 网上的教程是先配置系统变量，再配置系统变量中的path→**%MYSQL_HOME%\\bin** 配置完成后cmd显示 使用mysql workbench操作数据库本文教程在下载mysql时就已经下载了workbench，所以这里不需要再下载 输入密码登录mysql，进入数据库可以看到 -1 新建数据库 name时名称 下面是编码方式，设置完成后点击apply 会自动生成创建数据库的语句，再次点击apply即可 之后可以在侧边navigator看到新建的数据库，如果看不到，可以选择底部的administration变为schemas。 -2 对数据库的增删改查（1）设置连接 选中刚建好的数据库，右键，设置为此次链接的默认数据库 （2）新建表格：菜单栏第五个图标&#x2F;选中新建的数据库中的tables右键中create table 新建表格的项目中添加column，设置column的datatype，primarykey等属性，之后点击执行。 点击apply还会自动生成SQL语句 点击表旁边的小信号就可以查看表目前的各种信息，即数据表的结构。 （3）查看表格数据 选中表格→右键→选择select rows （4）修改表格数据 双击表格中的null，输入数据，输入完成后点击右下角apply 插入中文时报错可能是表的设置问题：报错1366 解决办法（1）：修改表格的编码方式为uft8后apply，+修改当前行的编码方式为utf8后apply. 找到表名或者列名的小信息符号 （在workbench中使用这种方式） （2）修改my.ini文件 cmd ： show variables like ‘character%’； 看到server的编码模式不是utf8 。 网上的教程是在mysqldata的安装目录下找到my.ini文件，在安装过程中设置了mysqldata的安装路径，这个时候找到安装路径，就可以看到my.ini文件 用打开文本的方式打开，找到mysql下面的 去掉default前面的井号，等号后面加上utf8， 再找到mysqld下面的 如最后一行所示，如上述操作一样。 完成后重启mysql服务: win+r 输入services.msc，其中找到mysql，本地用的是 net stop MySQL57net start MySQL57 如果不行的话，可以用管理员方式打开cmd。 错误原因： 1 提示服务名无效→查看windows下mysql服务的名称，如上图所示。 2 提示发生系统错误5 拒绝访问→未用管理员模式打开。 各种约束 主键约束，pk列即表示可操作数据表的主键约束，当勾选pk复选框时，该列就是数据表的主键。 外键约束，foreign key name，进入 Foreign Keys 标签，首先在 Foreign Key Name 中填入外键名称，其次在 Referenced Table 中选择当前数据库中的数据表，然后选择设置外键的字段，接着选择主表的关联字段，最后单击 Apply 按钮即可完成外键的添加操作，如下图所示。 唯一约束：UQ列表示数据表的唯一约束，当勾选UQ复选框时，代表该列就是数据表的唯一约束索引。 默认值约束：Default&#x2F;Expression 列中编辑字段的默认值。（NULL&#x2F;数字..） 非空约束：NN列表示数据表的非空约束，当勾选NN复选框时，表示该列为数据表的非空约束。 -3 数据库中的账号管理菜单栏server→Users and Privileges 点击add acount可以创建新的用户，其中右边的设置包括用户名称、验证类型，主机名称，密码，确认密码。 点击delete可以删除用户。 点击refresh可以刷新现在的用户。 将数据库映射到本地ip上供给局域网中的其他用户使用 http://t.zoukankan.com/diyunfei-p-6930794.html","categories":[],"tags":[]},{"title":"2022年6月9日学习primevue和连接数据库","slug":"2022年6月9日学习primevue和连接数据库","date":"2022-06-09T13:19:19.000Z","updated":"2022-06-18T09:44:35.744Z","comments":true,"path":"2022/06/09/2022年6月9日学习primevue和连接数据库/","link":"","permalink":"http://example.com/2022/06/09/2022%E5%B9%B46%E6%9C%889%E6%97%A5%E5%AD%A6%E4%B9%A0primevue%E5%92%8C%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/","excerpt":"","text":"[TOC] primevueprimevue 类似于elementui，可以通过引用相关的模块设置页面。 今天的需求是设计数据界面，根据datatable设计出页面的基本格式，之后通过插入iuputnumber模块将某些部分设计为可输入数据，这样的话就可以设计出自己想要的页面 感悟：首先要理解例子中模块是怎么设计的，然后按照需求修改。 连接MYSQLdb资料来自于实验室的同学，写一个博客开始自己写 设计一个数据表 字段就对应前端项目里 那个表格里的列 数据的各个类型 参考 plf_log 那个表的设计 一般这几种类型就够用了 在 navicat 里 ctrl +D 是设计表的快捷键 from select import selectconn = MySQLdb.connect(host = self.host, port=self.port, user = self.user, passwd = self.password, db = self.dbname, charset=&#x27;utf8&#x27;, autocommit=True) #连接cursor = conn.cursor() # 使用游标cursor.execute(f&quot;ALTER TABLE &#123;self.tablename&#125; ADD edge_pred real&quot;)cursor.execute(f&quot;ALTER TABLE &#123;self.tablename&#125; ADD cloud_pred real&quot;)cursor.execute(f&quot;ALTER TABLE &#123;self.tablename&#125; ADD y_interpolation real&quot;)selectupdata cursor = conn.cursor() # 使用游标//创建train_data数据库//创建train_data数据库drop = &quot;drop table if exists train_data&quot;sql_createTb = &quot;&quot;&quot;CREATE TABLE train_data ( id INT PRIMARY KEY AUTO_INCREMENT, timestamp DATETIME, ak1 real, ak2 real, add_alkali_flow real, slurry_flow real, steam_pressure real, steam_flow real, y real, y_interpolation real) &quot;&quot;&quot;cursor.execute(drop)head1 = &quot;id, timestamp, ak1, ak2, add_alkali_flow, slurry_flow, steam_pressure, steam_flow, y&quot;cursor.execute(f&#x27;select %s from writedata order by `id` desc limit 0,&#123;timestep+ filter_step&#125;&#x27;%head1) # 数据查询最新一个data = cursor.fetchall()y_true = y_old+ (y_now - y_old)/num * i # 得到了最近相邻的阶跃值，进行插值处理//把y_interpolation写入cursor.execute(f&quot;update writedata set y_interpolation=&#x27;&#123;y_true&#125;&#x27; where id=&#x27;&#123;id_old+ i&#125;&#x27;&quot;) cursor.execute(f&quot;update train_data set y_interpolation=&#x27;&#123;y_true&#125;&#x27; where id=&#x27;&#123;id_old+ i&#125;&#x27;&quot;) # 插补值写入 我自己写的代码 增删改查 import pymysql#1 连接数据库def get_conn(): conn = pymysql.connect( host=&#x27;&#x27;, port=13306, user=&#x27;root&#x27;, password=&#x27;&#x27;, db=&#x27;&#x27;, charset=&#x27;utf8&#x27;,autocommit=True, # 如果插入数据，， 是否自动提交? 和conn.commit()功能一致。​ )​ return conn#增加 def sql_insert_many(sql,args): conn = get_conn() cur = conn.cursor() # 创建游标 result = cur.executemany(query=sql, args=args) print(result) conn.commit() cur.close() conn.close()#删除def sql_delete(sql,args): conn = get_conn() cur = conn.cursor() result = cur.execute(sql,args) print(result) conn.commit() cur.close() conn.close()#更新def sql_update(sql,args): conn = get_conn() cur = conn.cursor() result = cur.execute(sql,args) print(result) conn.commit() cur.close() conn.close()#查询def sql_query(sql,args): conn = get_conn() cur = conn.cursor() cur.execute(sql,args) results = cur.fetchall() #print(type(results)) # 返回&lt;class &#x27;tuple&#x27;&gt; tuple元组类型​ for row in results:​ print(row)​ id = row[0]​ area_id = row[1]​ name = row[2]​ type = row[3]​ time = row[4]​ value = row[5]​ unit = row[6]​ print(&#x27; id: &#x27; + str(id) + &#x27; area_id: &#x27; + str(area_id) + &#x27; name: &#x27; + str(name) + &#x27; type: &#x27; + str(type) +&#x27; time: &#x27; + time +&#x27; value: &#x27; + str(value) + &#x27;unit&#x27;+str(unit) )​ pass​ conn.commit()​ cur.close()​ conn.close()def sql_search(): conn = get_conn(); cur = conn.cursor() sqli = &quot;select * from plf_data_fuel&quot; result = cur.execute(sqli) print(result) conn.commit() cur.close() conn.close()if __name__==&#x27;__main__&#x27;: #sql = &#x27;INSERT INTO plf_data_fuel VALUES(%s,%s,%s,%s,%s,%s,%s);&#x27; #args = [(0, &#x27;公司&#x27;,&#x27;选矿&#x27;,&#x27;指标&#x27;,&#x27;2022.6.11&#x27;,&#x27;150&#x27;,&#x27;升/千吨&#x27;), (1, &#x27;公司&#x27;,&#x27;采矿&#x27;,&#x27;消耗&#x27;,&#x27;2022.6.11&#x27;,&#x27;200&#x27;,&#x27;升&#x27;)]增加# sql = &#x27;DELETE FROM plf_data_fuel WHERE id = %s;&#x27;#args = (0,) # 单个元素的tuple写法sql_delete(sql,args)sql = &#x27;UPDATE plf_data_fuel SET value=%s WHERE id = %s;&#x27;args = (&#x27;150&#x27;, 0)sql_update(sql, args)sql = &#x27;SELECT * FROM plf_data_fuel;&#x27;sql_query(sql,None) CHA","categories":[],"tags":[]},{"title":"win10用命令行运行python脚本","slug":"win10用命令行运行python脚本","date":"2022-06-05T03:10:12.000Z","updated":"2022-06-16T09:19:51.229Z","comments":true,"path":"2022/06/05/win10用命令行运行python脚本/","link":"","permalink":"http://example.com/2022/06/05/win10%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BF%90%E8%A1%8Cpython%E8%84%9A%E6%9C%AC/","excerpt":"","text":"[TOC] win10用命令行运行python脚本1.解决输入pyhton后转入microsoft store （1）将anaconda加入环境变量中 此电脑右键→属性→关于下面的高级系统设置→对用户变量和系统变量的path*进行编辑→新建三个anaconda环境变量（最下面的三个） （2）windows搜索栏输入管理应用执行别名→应用安装程序python取消勾选 2.打开cmd命令行 （1）输入python代表进入python交互模式，可以通过输入代码得到相应的结果。 如果输入python没有进入交互模式，因为本机用的是anaconda，所以输入 conda info --envs查看环境 将py3虚拟环境激活： conda activate py3 激活后自动进入python虚拟环境，此时进入了交互模式 （2）进入.py文件所在的位置，打开cmd命令行，（等价于在当前文件夹右键打开windows powershell）输入python test.py，可以运行python脚本，例如： python调用cmd3种方式 1.python的OS模块os模块调用cmd命令有两种方式：**os.system()、os.popen()**都是用当前进程来调用。 -（1）**os.system()**是无法获取返回值的。当运行结束后接着往下面执行程序。 import os os.system(&quot;ipconfig&quot;) 报错并显示： 这个显示的是cmd下的结果，解决方案： 配置默认终端为powershell 打开终端→选择默认配置文件→选择powershell→运行程序即可 ps：之后再将默认终端换为cmd时发现不再报错。。。 -（2）os.popen()带返回值的，如何获取返回值。如： import oscmd=&#x27;python&#x27;p = os.popen(cmd)Output_str = p.read()print (Output_str) 得到的是个字符串。 这两个都是用当前进程来调用，它们都是阻塞式的。 （1）首先理解括号里面的程序 cd &#x2F;××&#x2F;×× 进入文件夹 svn update注：后面也可以指定目录如果命令后无目录，则将当前目录及其子目录下的所有文件都更新到最新版本。 python manage.py db migrate python manage.py db upgrade 实际开发中使用flask-migrate来动态的迁移数据库，使用flask-migrate必须借助flask-script Pid 文件是包含进程标识号 (pid) 的文件，该文件存储在文件系统的明确定义位置，因此允许其他程序找出正在运行的脚本的 pid。 下面两种方法仅是记录。 2.管道subprocess模块（使用Popen模块产生新的process）运行原理会在当前进程下面产生子进程。 sub=subprocess.Popen(cmd,shell=True,stdout=subprocess.PIPE)sub.wait()print sub.read() 现在大部分人都喜欢使用Popen。Popen方法不会打印出cmd在linux上执行的信息。的确，Popen非常强大，支持多种参数和模式。使用前需要from subprocess import Popen, PIPE。但是Popen函数有一个缺陷，就是它是一个阻塞的方法。如果运行cmd时产生的内容非常多，函数非常容易阻塞住。解决办法是不使用wait()方法，但是也不能获得执行的返回值了。 Popen原型是： [python] subprocess.Popen(args, bufsize&#x3D;0, executable&#x3D;None, stdin&#x3D;None, stdout&#x3D;None, stderr&#x3D;None, preexec_fn&#x3D;None, close_fds&#x3D;False, shell&#x3D;False, cwd&#x3D;None, env&#x3D;None, universal_newlines&#x3D;False, startupinfo&#x3D;None, creationflags&#x3D;0) 参数bufsize：指定缓冲。我到现在还不清楚这个参数的具体含义，望各个大牛指点。 参数executable用于指定可执行程序。一般情况下我们通过args参数来设置所要运行的程序。如果将参数shell设为 True，executable将指定程序使用的shell。在windows平台下，默认的shell由COMSPEC环境变量来指定。 参数stdin, stdout, stderr分别表示程序的标准输入、输出、错误句柄。他们可以是PIPE，文件描述符或文件对象，也可以设置为None，表示从父进程继承。 参数preexec_fn只在Unix平台下有效，用于指定一个可执行对象(callable object)，它将在子进程运行之前被调用。 参数Close_sfs：在windows平台下，如果close_fds被设置为True，则新创建的子进程将不会继承父进程的输入、输出、错误管 道。我们不能将close_fds设置为True同时重定向子进程的标准输入、输出与错误(stdin, stdout, stderr)。 如果参数shell设为true，程序将通过shell来执行。 参数cwd用于设置子进程的当前目录。 参数env是字典类型，用于指定子进程的环境变量。如果env &#x3D; None，子进程的环境变量将从父进程中继承。 参数Universal_newlines:不同操作系统下，文本的换行符是不一样的。如：windows下用’&#x2F;r&#x2F;n’表示换，而Linux下用 ‘&#x2F;n’。如果将此参数设置为True，Python统一把这些换行符当作’&#x2F;n’来处理。 参数startupinfo与createionflags只在windows下用效，它们将被传递给底层的CreateProcess()函数，用 于设置子进程的一些属性，如：主窗口的外观，进程的优先级等等。 subprocess.PIPE 在创建Popen对象时，subprocess.PIPE可以初始化stdin, stdout或stderr参数，表示与子进程通信的标准流。 subprocess.STDOUT 创建Popen对象时，用于初始化stderr参数，表示将错误通过标准输出流输出。 Popen的方法： Popen.poll() 用于检查子进程是否已经结束。设置并返回returncode属性。 Popen.wait() 等待子进程结束。设置并返回returncode属性。 Popen.communicate(input&#x3D;None) 与子进程进行交互。向stdin发送数据，或从stdout和stderr中读取数据。可选参数input指定发送到子进程的参数。 Communicate()返回一个元组：(stdoutdata, stderrdata)。注意：如果希望通过进程的stdin向其发送数据，在创建Popen对象的时候，参数stdin必须被设置为PIPE。同样，如 果希望从stdout和stderr获取数据，必须将stdout和stderr设置为PIPE。 Popen.send_signal(signal) 向子进程发送信号。 Popen.terminate() 停止(stop)子进程。在windows平台下，该方法将调用Windows API TerminateProcess()来结束子进程。 Popen.kill() 杀死子进程。 Popen.stdin 如果在创建Popen对象是，参数stdin被设置为PIPE，Popen.stdin将返回一个文件对象用于策子进程发送指令。否则返回None。 Popen.stdout 如果在创建Popen对象是，参数stdout被设置为PIPE，Popen.stdout将返回一个文件对象用于策子进程发送指令。否则返回 None。 Popen.stderr 如果在创建Popen对象是，参数stdout被设置为PIPE，Popen.stdout将返回一个文件对象用于策子进程发送指令。否则返回 None。 Popen.pid 获取子进程的进程ID。 Popen.returncode 获取进程的返回值。如果进程还没有结束，返回None。 例如： [python] p &#x3D; Popen(“cp -rf a&#x2F;* b&#x2F;“, shell&#x3D;True, stdout&#x3D;PIPE, stderr&#x3D;PIPE) p.wait() if p.returncode !&#x3D; 0: print “Error.” return -1————————————————版权声明：本文为CSDN博主「Sahadhammika」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/weixin_28419039/article/details/112825756 3.使用commands.getstatusoutput(‘cmd’)方法status ,output = commands.getstatusoutput(&#x27;cmd&#x27;)status = commands.getstatus(&#x27;cmd&#x27;)output = commands.getoutput(&#x27;cmd&#x27;) 顾名思义，status，output分别是执行的状态和输出结果，但是这种方法在windows中不能用。这个方法也不会打印出cmd在linux上执行的信息。这个方法唯一的优点是，它不是一个阻塞的方法。即没有Popen函数阻塞的问题。使用前需要import commands。 例如： [python] status, output &#x3D; commands.getstatusoutput(“ls”) 还有只获得output和status的方法： [python] commands.getoutput(“ls”) commands.getstatus(“ls”)————————————————版权声明：本文为CSDN博主「Sahadhammika」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/weixin_28419039/article/details/112825756","categories":[],"tags":[]},{"title":"docker安装及使用经验","slug":"docker安装及使用经验","date":"2022-06-03T00:31:14.000Z","updated":"2022-06-04T15:18:41.058Z","comments":true,"path":"2022/06/03/docker安装及使用经验/","link":"","permalink":"http://example.com/2022/06/03/docker%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E7%BB%8F%E9%AA%8C/","excerpt":"","text":"docker[TOC] 前提是在vscode上面使用docker命令时发现命令无法识别，在vscode中下载扩展docker后也依旧不行，后推断原因是本机并没有下载过docker,因此下面探究如何在windows系统下下载并使用docker。整个思路：首先下载docker desktop并配置好，之后在vscode中下载扩展，最后在程序中使用docker命令进行操作。 本机以前装过虚拟机，在很多教程中都需要下载hype，但是有解释说hyper下载后其他的虚拟机不能使用，所以本教程是在未下载hyper的情况下使用docker 关键词：docker+wsl 2， docker+vscode，远程连接已有的docker镜像并上传内容安装docker 搜索docker官网，下载适合于windows版本的docker desktop，下载成功后可以通过命令行cmd输入 docker --version 查看是否下载docker成功。 运行docker run hello-world时发现报错，打开docker desktop 同样发现报错，提示未下载WL2，网上教程和windows官方教程开始下载 WL2. 下载WL2 以管理员身份运行powershell &#x3D;&#x3D; （win+r 输入powershell ） + （打开后输入start-process PowerShell -verb runas即可进入管理员 模式的powershell，输入下面的代码： *wsl --install* 若运行之后返回帮助文档，即下列情况： 那么这个时候需要按顺序输入： *wsl --list --online*→查看可用发行版本 运行*wsl --install -d &lt;DistroName&gt;*→我选的ubuntu，把-d后面的替换掉即可&#x3D;&#x3D;wsl –install -d ubuntu 之后会要求设置账号和密码，设置linux用户名和密码，在下载时系统会提醒设置username和password，此用户名和密码特定于安装的每个单独的linux分发版，与windows用户名无关；能够运行sudo（super user do）管理命令。 账号：amang密码： 输入命令 wsl --list --verbose 查看安装在 Windows 计算机上的 Linux 发行版列表，其中包括状态（发行版是正在运行还是已停止）。 ubuntu默认的wsl版本是1，此时不要慌张，上述步骤是wsl官方给的安装目录下的第一个安装教程，接下来跳到第二个安装教程：**旧版本的手动安装步骤**。 启用适用于linux的windows子系统 （1） 启用适用于 Linux 的 Windows 子系统： 以管理员身份运行powershell dism.exe /online /enable-feature /featurename:Microsoft-Windodiws-Subsystem-Linux /all /norestart 结果会出现： -（2）检查自己电脑是否满足wl2的运行要求 以本机为例：X64，内部版本号19043，次要版本号1706，均高于所需的。查看自己电脑的版本。win+r输入winver，可以查看到 -（3）启用虚拟机功能 安装 WSL 2 之前，必须启用“虚拟机平台”可选功能。 计算机需要虚拟化功能才能使用此功能。 在powershell下面运行： dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart~~ -（4）下载linux内核更新包← 非常重要！！！！非常重要 下载适用于x64计算的WSL2 linux 内核更新包 下载完后打开docker desktop会发现不报错了，不会再提醒WSL2没下载成功！！！ 查看wsl，会发现 此时代表docker desktop可以打开了！ 配置docker首先知道报错的类型： 代表docker没有打开，这个时候可以看 docker desktop打开后是否表明正在运行 ↑ 这里是绿色，表示正在运行！！ 如果是别的颜色，表示没有运行。 上述报错可以从以下考虑： -（1）wsl2没配置好–可以从docker desktop上提示看到 … ​ https和http问题 docker没有配置信任路径： 上述是原始代码，需要加入 “insecure-registries”: [ “信任路径”] 然后登录，可以发现ok了。 在vscode中使用docker 下载扩展 之后就可以在vscode中使用docker了。 如何在连接docker的问题：通过登录docker docker login dorker镜像网址 docker pull 路径:latest docker build -t 路径latest . ← 有一个点，代表一层 docker push hub.路径:latest 2.出错类型及解决： （1）build时报错 push时报错 这个时候虽然镜像容器会create，但是实则不会push成功。 使用时需要查看有没有这个文件，同时根据需要修改后面的路径 （2）当（1）中的问题解决以后，会出现 X509错误，这个时候build之前最好pull一下之前的文件，之后build，push，会发现成功了。 总结： （1）docker最好用在虚拟环境下，但通过本教程可以在windows下面使用docker. （2）doker下载完之后需要配置WSL2，如果没有的话需要自行配置，不管是wsl 1 还是wsl 2 ，可以在控制面板→程序→启用或关闭windows功能，查看 这个是否勾选。 （3）下载过程中发现了一个很好用的软件：windows teminals。 安装 Windows 终端安装 | Microsoft Docs Windows Terminal 可以使用命令行接口运行任何应用程序。 它的主要功能包括多个选项卡、窗格、Unicode 和 UTF-8 字符支持、GPU 加速文本呈现引擎，你还可用它来创建你自己的主题并自定义文本、颜色、背景和快捷方式。 每当安装新的 WSL Linux 发行版时，都会在 Windows Terminal 中为其创建一个新实例，该实例可根据你的偏好进行自定义。 （4）开始通过适用于 Linux 的 Windows 子系统使用 Visual Studio Code a 在vscode中下载扩展 Remote - WSL。 b 在vscode中打开WSL项目。 在刚才下载的windows终端输入 code . c 从vscode中下载 还可以通过使用 VS Code 中的快捷方式 CTRL+SHIFT+P 调出命令面板，以访问更多 VS Code 远程选项。 如果随后键入 Remote-WSL，将看到可用的 VS Code 远程选项列表，使你可以在远程会话中重新打开文件夹，指定要在哪个发行版中打开，等等。 （5）用第一种安装方式安装WSL时选择ubuntu ，通过windows teminals可以发现建立了一个ubuntu虚拟机， 而且对应的wsl是 1，可以在windows powershell 管理员模式下输入wsl –set-version 2， 就是更新的linux发行版的名称，比如我最开始使用的是ubuntu，这里直接替换为wsl --set-version ubuntu 2，通过命令wsl --list --verbose可以看到版本变了： 这里有个思考，其实docker desktop用的其实是手动安装的wsl安装包下载的wsl2. （6）一些wsl 2代码 wsl --set-version&#x3D;&#x3D;wsl -l -v →查看linux发行版的wsl版本 wsl --install wsl --list --online wsl --install -d &lt;DistroName&gt; （7）关于图片加载不成功的问题 绝对路径和相对路径 偏好设置中勾选优先使用相对路径，这个上传到github上才能看到 。 绝对：前面有磁盘等要素 相对 2022.06.04完成","categories":[],"tags":[]},{"title":"近期学习所思所想暂且存放之处","slug":"近期学习所思所想暂且存放之处","date":"2022-04-14T12:40:01.000Z","updated":"2022-04-14T14:01:05.722Z","comments":true,"path":"2022/04/14/近期学习所思所想暂且存放之处/","link":"","permalink":"http://example.com/2022/04/14/%E8%BF%91%E6%9C%9F%E5%AD%A6%E4%B9%A0%E6%89%80%E6%80%9D%E6%89%80%E6%83%B3%E6%9A%82%E4%B8%94%E5%AD%98%E6%94%BE%E4%B9%8B%E5%A4%84/","excerpt":"","text":"2022.4.14首先是ES6的学习今日大概搞清楚了生成器函数的声明和调用，通过下述的例子，表明我个人的理解： 题目：1）异步编程；2）1s后控制台打印111，2s后222，3s后333 思考：本文可以用setTimeout嵌套进行设计，但是如果嵌套的多，会有回调地狱，所以根据课程，本文使用生成器函数进行调用，生成器函数的声明和调用： function * gen()&#123; 第一个代码块 yield 111 第二个代码块 yield 222 第三个代码块 yield 333&#125;//调用let iteratior = gen()iterator.next()/ console.log(iterator.next)具体的细节等后期整理笔记时说出区别 针对刚开始的需求，设计代码如下： &lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewpoint&quot; content=&quot;width=device-width,initial-scale=1.0&quot;&gt; &lt;title&gt;生成器函数实例&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; //生成器函数异步变成，要求1s后显示111，2s后显示222，3s后显示333 function one()&#123; setTimeout(()=&gt;&#123; console.log(111) &#125;,1000) &#125; function two()&#123; setTimeout(()=&gt;&#123; console.log(222) &#125;,2000) &#125; function three()&#123; setTimeout(()=&gt;&#123; console.log(333) &#125;,3000) &#125; function *gen()&#123; one(); yield 111; two(); yield 222; three(); yield 333; &#125; let iterator = gen() console.log(iterator.next()) iterator.next() iterator.next() iterator.next() &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 首先定义了三个函数（其中setTimeout使用了箭头函数），之后定义了生成器函数gen（），之后调用，在这个过程中思考如下： （1）声明时：可以这么 function *gen()&#123; one(); yield 111; two(); yield 222; three(); yield 333; &#125; 也可以这么 function *gen()&#123; yield one(); yield two(); yield three(); &#125; 说明执行迭代器的时候，虽然是一个代码块一个代码块的执行，但yield是一个代码段的分隔，所以yield后面的代码会随着第一个next的执行而执行：也就是说，第二个代码和第一个代码性质相同。那么为什么yield 111 不会显示呢，暂时猜想可能是因为one是函数，函数有执行的对象，所以就直接执行了，而111就是个数。 （2）调用时，可以把next()函数写在一起，也可以把它写在yield调用的函数里面。例如： function one()&#123; setTimeout(()=&gt;&#123; console.log(111) iterator.next() &#125;,1000) &#125; 生成器函数应用2 调用用户数据订单数据和商品数据","categories":[],"tags":[]},{"title":"hexo+github(二)","slug":"hexo-github-二","date":"2022-04-09T13:50:59.000Z","updated":"2022-06-16T09:47:24.459Z","comments":true,"path":"2022/04/09/hexo-github-二/","link":"","permalink":"http://example.com/2022/04/09/hexo-github-%E4%BA%8C/","excerpt":"","text":"一 选择hexo自带的的图片插件 a:下载插件 hexo-asset-image npm install hexo-asset-image –save b：如果想添加图片到已经存在的md文件，那么这个时候直接自己创建一个与md文件同名的文件夹存放图片； ​ 如果这个时候还没有创建md文件，可以选择hexo n 新建一个md文件，这个时候可以看到自动创建了一个与md同名的文件夹。 c：更改congif.yml文件里面的post_asset_folder: false更改为post_asset_folder: true。 d：更改node.module&#x2F;hexo-asset-image下面的配置文件index.js为： &#x27;use strict&#x27;;var cheerio = require(&#x27;cheerio&#x27;);// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-stringfunction getPosition(str, m, i) &#123; return str.split(m, i).join(m).length;&#125;hexo.extend.filter.register(&#x27;after_post_render&#x27;, function(data)&#123; var config = hexo.config; if(config.post_asset_folder)&#123; var link = data.permalink; var beginPos = getPosition(link, &#x27;/&#x27;, 3) + 1; var appendLink = &#x27;&#x27;; // In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;. // if not with index.html endpos = link.lastIndexOf(&#x27;.&#x27;) + 1 support hexo-abbrlink if(/.*\\/index\\.html$/.test(link)) &#123; // when permalink is end with index.html, for example 2019/02/20/xxtitle/index.html // image in xxtitle/ will go to xxtitle/index/ appendLink = &#x27;index/&#x27;; var endPos = link.lastIndexOf(&#x27;.&#x27;); &#125; else &#123; var endPos = link.lastIndexOf(&#x27;/&#x27;); &#125; link = link.substring(beginPos, endPos) + &#x27;/&#x27; + appendLink; var toprocess = [&#x27;excerpt&#x27;, &#x27;more&#x27;, &#x27;content&#x27;]; for(var i = 0; i &lt; toprocess.length; i++)&#123; var key = toprocess[i]; var $ = cheerio.load(data[key], &#123; ignoreWhitespace: false, xmlMode: false, lowerCaseTags: false, decodeEntities: false &#125;); $(&#x27;img&#x27;).each(function()&#123; if ($(this).attr(&#x27;src&#x27;))&#123; // For windows style path, we replace &#x27;\\&#x27; to &#x27;/&#x27;. var src = $(this).attr(&#x27;src&#x27;).replace(&#x27;\\\\&#x27;, &#x27;/&#x27;); if(!(/http[s]*.*|\\/\\/.*/.test(src) || /^\\s+\\//.test(src) || /^\\s*\\/uploads|images\\//.test(src))) &#123; // For &quot;about&quot; page, the first part of &quot;src&quot; can&#x27;t be removed. // In addition, to support multi-level local directory. var linkArray = link.split(&#x27;/&#x27;).filter(function(elem)&#123; return elem != &#x27;&#x27;; &#125;); var srcArray = src.split(&#x27;/&#x27;).filter(function(elem)&#123; return elem != &#x27;&#x27; &amp;&amp; elem != &#x27;.&#x27;; &#125;); if(srcArray.length &gt; 1) srcArray.shift(); src = srcArray.join(&#x27;/&#x27;); $(this).attr(&#x27;src&#x27;, config.root + link + src); console.info&amp;&amp;console.info(&quot;update link as:--&gt;&quot;+config.root + link + src); &#125; &#125;else&#123; console.info&amp;&amp;console.info(&quot;no src attr, skipped...&quot;); console.info&amp;&amp;console.info($(this)); &#125; &#125;); data[key] = $.html(); &#125; &#125;&#125;); tips：在本人尝试时为成功，老师指导后知道，是因为源程序正则表达式有问题，在博客对图片进行检查时发现映射的地址为.&#x2F;com，这个地址并不是本地的地址，更改正则表达式后发现可以找到本地图片的地址。 可以在index.js中加入console.info语句打印变量，查看问题！！！！ f：重启hexo服务器 hexo s 如果重启后仍然看不到图片，可以按顺序运行以下代码： hexo clean hexo g hexo d hexo s 修改样式： 到github上下载主题 git clone 。。。。 然后将hexo&#x2F;blog下的config文件中的theme的名称改为想要更改的主题的名称 hexo clean 清理缓存 hexo g 生成文件 hexo d 部署","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}]},{"title":"hexo+github","slug":"hexo-github-一","date":"2022-04-08T13:57:23.000Z","updated":"2022-06-16T14:18:07.083Z","comments":true,"path":"2022/04/08/hexo-github-一/","link":"","permalink":"http://example.com/2022/04/08/hexo-github-%E4%B8%80/","excerpt":"","text":"hexo和github连接免费搭建个人博客网站(小白)一 先下载node和git，这个我都已经下载了，所以这一步详细步骤省略，等之后在笔记本上尝试时再添加。下载完成后可以通过 -v &#x2F;-version查看node、npm和git版本确定是否下载成功 二 注册github账号，并创建仓库，设置ssh连接 （1）点击头像，选择new reposity，新建一个名为：用户名.github.io的仓库，比如说我的用户名是leoamang，那么我需要建立一个名为leoamang.github.io的仓库。 （2）配置SSH key：使用ssh key解决本地和服务器的连接问题。 a：在桌面上（我做的时候并没有在桌面上，就是任意的文件夹，不知道是否只有桌面才成功，待验证）使用git base here进行命令行，输入 git config –global user.name “username” (例如：git config –global user.name “leoamang”)， 输入git config –global user.email “youremail” (例如git config –global user.email “***@qq.com”）。 b：创建SSH，输入后一路回车就行 ssh-keygen -t rsa -C “youremail”（C大写） ​ C：在路径C:\\Users\\DELL.ssh的id_rsa.pub可以看到生成的ssh密钥。打开并复制。 （3）在github上设置密钥：点击头像→settings→找到ssh and GPG keys→new ssh key→粘贴复制的ssh密钥，随意起个名字，并保存。检查设置是否成功 ssh -T &#x67;&#105;&#116;&#x40;&#103;&#105;&#x74;&#x68;&#x75;&#98;&#x2e;&#x63;&#x6f;&#109; 若出现Hi username！ You’ve successfully authenticated, but GitHub does not provide shell access. 三 下载hexo 在自己想要的位置创建一个文件夹，名叫hexo，在这个文件夹下打开git bash here 使用npm全局安装hexo框架和deployer： npm install -g hexo-cli npm install hexo-deployer-git –save 若安装速度慢，或者不成功，更换npm镜像源（我第一次没成功，更换镜像源后成功） npm config set registry https://registry.npm.taobao.org。 安装完成后，初始化博客，会在hexo文件夹下面创建一个blog文件，或者直接hexo init不会创建blog文件夹 npm init blog 检测是否可以，新建一个新的博客，然后执行g和s，打开浏览器访问4000端口查看。 hexo n “test“ &#x3D;&#x3D;&#x3D; hexo new ”test“ hexo g hexo s ctrl+c可以退出hexo服务器 四 推送博客 在blog文件下面找到config.yml配置及文件，修改最后的内容为（注意冒号之后有空格，不然会提示出错）： type: gitrepo: github下的仓库的完整路径branch: master 上述都成功后，可以在blog&#x2F;source&#x2F;__post下面创建md文件，写完之后可以通过 hexo g -d 或者hexo d推送 常用命令： hexo n “博客名” &#x3D;&#x3D;&#x3D; hexo new “博客名” hexo g &#x3D;&#x3D;&#x3D; hexo generate 生成静态页面至public目录 hexo s &#x3D;&#x3D;&#x3D; hexo server 开启预览访问端口（ctrl+c退出） hexo d &#x3D;&#x3D;&#x3D; hexo deploy 部署到github hexo s -g 生成并本地预览 hexo g -d 生成并上传 &#x3D;&#x3D;&#x3D; hexo d -g","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2022-04-06T13:45:39.129Z","updated":"2022-04-06T13:45:39.129Z","comments":true,"path":"2022/04/06/hello-world/","link":"","permalink":"http://example.com/2022/04/06/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"li","slug":"li","permalink":"http://example.com/tags/li/"},{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}]}